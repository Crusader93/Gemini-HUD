name: GHUD Solo Remote Controller v1.0.0

slots:
    core:
        class: CoreUnit
    antigrav:
        class: AntiGravityGeneratorUnit
    warpdrive:
        class: WarpDriveUnit
    atmofueltank:
        class: AtmoFuelContainer
        select: manual
    spacefueltank:
        class: SpaceFuelContainer
        select: manual
    rocketfueltank:
        class: RocketFuelContainer
        select: manual
    shield:
        class: ShieldGeneratorUnit
    weapon:
        class: WeaponUnit
        select: manual
    radar:
        class: RadarPVPUnit
        select: manual
    databank:
        class: DatabankUnit
        select: manual

handlers:
    unit:
        onStart:
            lua: |
                pitchInput = 0
                rollInput = 0
                yawInput = 0
                brakeInput = 0

                Nav = Navigator.new(system, core, unit)
                Nav.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal, {1000, 5000, 10000, 20000, 30000})
                Nav.axisCommandManager:setTargetGroundAltitude(-1)

                -- Parenting widget
                --parentingPanelId = system.createWidgetPanel("Docking")
                --parentingWidgetId = system.createWidget(parentingPanelId,"parenting")
                --system.addDataToWidget(unit.getWidgetDataId(),parentingWidgetId)

                -- Combat stress widget
                --coreCombatStressPanelId = system.createWidgetPanel("Core combat stress")
                --coreCombatStressgWidgetId = system.createWidget(coreCombatStressPanelId,"core_stress")
                --system.addDataToWidget(core.getWidgetDataId(),coreCombatStressgWidgetId)

                -- element widgets
                -- For now we have to alternate between PVP and non-PVP widgets to have them on the same side.
                --_autoconf.displayCategoryPanel(weapon, weapon_size, L_TEXT("ui_lua_widget_weapon", "Weapons"), "weapon", true)
                --core.showWidget()
                --_autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_periscope", "Periscope"), "periscope")
                --placeRadar = true
                --if atmofueltank_size > 0 then
                    --_autoconf.displayCategoryPanel(atmofueltank, atmofueltank_size, L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"), "fuel_container")
                    --if placeRadar then
                        --_autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_radar", "Radar"), "radar")
                        --placeRadar = false
                    --end
                --end
                --if spacefueltank_size > 0 then
                    --_autoconf.displayCategoryPanel(spacefueltank, spacefueltank_size, L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"), "fuel_container")
                    --if placeRadar then
                        --_autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_radar", "Radar"), "radar")
                        --placeRadar = false
                    --end
                --end
                --_autoconf.displayCategoryPanel(rocketfueltank, rocketfueltank_size, L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"), "fuel_container")
                --if placeRadar then -- We either have only rockets or no fuel tanks at all, uncommon for usual vessels
                    --_autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_radar", "Radar"), "radar")
                    --placeRadar = false
                --end
                --if antigrav ~= nil then antigrav.showWidget() end
                --if warpdrive ~= nil then warpdrive.showWidget() end
                --if gyro ~= nil then gyro.showWidget() end
                --if shield ~= nil then shield.showWidget() end

                -- freeze the player in he is remote controlling the construct
                if unit.isRemoteControlled() == 1 then
                    player.freeze(1)
                end

                -- landing gear
                -- make sure every gears are synchonized with the first
                gearExtended = (unit.isAnyLandingGearDeployed() == 1) -- make sure it's a lua boolean
                if gearExtended then
                    unit.deployLandingGears()
                else
                    unit.retractLandingGears()
                end
                -- GEMINI FOUNDATION

                --Solo remote controller
                HUD_version = '1.0.0'

                --LUA parameters

                --vars
                atlas = require("atlas")
                stellarObjects = atlas[0]
                shipPos = vec3(construct.getWorldPosition())
                safeWorldPos = vec3({13771471,7435803,-128971})

                --shield
                damageLine = ''
                ccsLineHit = ''
                damage = 0
                maxSHP = 210 --svg shield X right side coordinate
                shieldMaxHP = shield.getMaxShieldHitpoints()
                last_shield_hp = shield.getShieldHitpoints()
                HP = shield.getShieldHitpoints()/shieldMaxHP * 100
                svghp = maxSHP * (HP * 0.01)

                --CCS
                ccshit = 0
                maxCCS = 139.5
                coreMaxStress = core.getmaxCoreStress()
                last_core_stress = core.getCoreStress()
                CCS = last_core_stress/coreMaxStress * 100
                ccshp1 = maxCCS * (CCS * 0.01)
                ccshp = ccshp1

                --FUEL
                maxFUEL = maxCCS
                fuel_lvl = json.decode(spacefueltank_1.getWidgetData()).percentage
                FUEL_svg = maxFUEL * (fuel_lvl * 0.01)

                AM_last_stress = 0
                EM_last_stress = 0
                TH_last_stress = 0
                KI_last_stress = 0
                AM_svg = 0
                EM_svg = 0
                TH_svg = 0
                KI_svg = 0

                if warpdrive ~= nil then
                avWapr = warpdrive.getRequiredWarpCells()
                totalWarp = warpdrive.getAvailableWarpCells()
                unit.setTimer('warp',1)
                else
                avWapr = 0
                totalWarp = 0
                end

                function resistance_SVG()
                local res = shield.getResistances()
                if res[1] > 0 then
                    AM_stroke_color = '#FFB12C'
                    AMstrokeWidth = 2
                else
                    AM_stroke_color = 'rgb(66, 167, 245)'
                    AMstrokeWidth = 1
                end
                if res[2] > 0 then
                    EM_stroke_color = '#FFB12C'
                    EMstrokeWidth = 2
                else
                    EM_stroke_color = 'rgb(66, 167, 245)'
                    EMstrokeWidth = 1
                end
                if res[3] > 0 then
                    KI_stroke_color = '#FFB12C'
                    KIstrokeWidth = 2
                else
                    KI_stroke_color = 'rgb(66, 167, 245)'
                    KIstrokeWidth = 1
                end
                if res[4] > 0 then
                    TH_stroke_color = '#FFB12C'
                    THstrokeWidth = 2
                else
                    TH_stroke_color = 'rgb(66, 167, 245)'
                    THstrokeWidth = 1
                end
                end

                function actionRes(res)
                if res[1] > 0 then
                    AM_stroke_color = '#FFB12C'
                    AMstrokeWidth = 2
                    unit.setTimer('AM',0.016)
                else
                    AM_stroke_color = 'rgb(66, 167, 245)'
                    AMstrokeWidth = 1
                end
                if res[2] > 0 then
                    EM_stroke_color = '#FFB12C'
                    EMstrokeWidth = 2
                    unit.setTimer('EM',0.016)
                else
                    EM_stroke_color = 'rgb(66, 167, 245)'
                    EMstrokeWidth = 1
                end
                if res[3] > 0 then
                    KI_stroke_color = '#FFB12C'
                    KIstrokeWidth = 2
                    unit.setTimer('KI',0.016)
                else
                    KI_stroke_color = 'rgb(66, 167, 245)'
                    KIstrokeWidth = 1
                end
                if res[4] > 0 then
                    TH_stroke_color = '#FFB12C'
                    THstrokeWidth = 2
                    unit.setTimer('TH',0.016)
                else
                    TH_stroke_color = 'rgb(66, 167, 245)'
                    THstrokeWidth = 1
                end
                end

                resistance_SVG()
                am=0
                am_x = -50
                am_opacity = 1
                em=0
                em_x = -50
                em_opacity = 1
                ki=0
                ki_x = 339
                ki_opacity = 1
                th=0
                th_x = 339
                th_opacity = 1
                AM_res = ''
                EM_res = ''
                KI_res = ''
                TH_res = ''

                function damage_SVG()
                if damage > 0 then
                    damage = damage - 0.1
                    damageLine = [[<rect x="]].. svghp + 145 ..[[" y="225" width="]]..damage..[[" height="50" style="fill: #de1656; stroke: #de1656;" bx:origin="0.5 0.5"/>]]
                end
                if damage <= 0 then
                    damage = 0
                    damageLine = ''
                end

                if ccshit > 0 then
                    ccshp = ccshp + 0.25
                    if ccshp >= ccshp1 then
                        ccshp = ccshp1
                        ccsLineHit = ''
                        ccshit = 0
                    end
                end
                end

                function ccs_SVG()
                --AM
                if AM_stress ~= AM_last_stress then
                    AM_last_stress = AM_stress
                end
                if AM_svg < AM_last_stress then
                    AM_svg = AM_svg + 0.01
                    if AM_svg >= AM_stress then AM_svg = AM_stress
                end
                end
                if AM_svg > AM_last_stress then
                AM_svg = AM_svg - 0.01
                if AM_svg <= AM_stress then AM_svg = AM_stress end
                end
                --EM
                if EM_stress ~= EM_last_stress then
                EM_last_stress = EM_stress
                end
                if EM_svg < EM_last_stress then
                EM_svg = EM_svg + 0.01
                if EM_svg >= EM_stress then EM_svg = EM_stress end
                end
                if EM_svg > EM_last_stress then
                EM_svg = EM_svg - 0.01
                if EM_svg <= EM_stress then EM_svg = EM_stress end
                end
                --TH
                if TH_stress ~= TH_last_stress then
                TH_last_stress = TH_stress
                end
                if TH_svg < TH_last_stress then
                TH_svg = TH_svg + 0.01
                if TH_svg >= TH_stress then TH_svg = TH_stress end
                end
                if TH_svg > TH_last_stress then
                TH_svg = TH_svg - 0.01
                if TH_svg <= TH_stress then TH_svg = TH_stress end
                end
                --KI
                if KI_stress ~= KI_last_stress then
                KI_last_stress = KI_stress
                end
                if KI_svg < KI_last_stress then
                KI_svg = KI_svg + 0.01
                if KI_svg >= KI_stress then KI_svg = KI_stress end
                end
                if KI_svg > KI_last_stress then
                KI_svg = KI_svg - 0.01
                if KI_svg <= KI_stress then KI_svg = KI_stress end
                end
                end

                local stress = shield.getStressRatioRaw()
                AM_stress = stress[1]
                EM_stress = stress[2]
                KI_stress = stress[3]
                TH_stress = stress[4]

                ccs_SVG()

                function setTag(tag)
                local tag = tag:sub(5)
                system.print('Activated new transponder tag "'..tag..'"')
                tag = {tag}
                transponder.setTags(tag)
                end

                function zeroConvertToWorldCoordinates(pos)
                local num  = ' *([+-]?%d+%.?%d*e?[+-]?%d*)'
                local posPattern = '::pos{' .. num .. ',' .. num .. ',' ..  num .. ',' .. num ..  ',' .. num .. '}'
                local systemId, bodyId, latitude, longitude, altitude = string.match(pos, posPattern)

                if systemId==nil or bodyId==nil or latitude==nil or longitude==nil or altitude==nil then
                system.print("Invalid pos!")
                destination_bm=""
                return vec3()
                end

                if (systemId == "0" and bodyId == "0") then
                --convert space bm
                return vec3(latitude,
                longitude,
                altitude)
                end
                longitude = math.rad(longitude)
                latitude = math.rad(latitude)
                local planet = atlas[tonumber(systemId)][tonumber(bodyId)]
                local xproj = math.cos(latitude);
                local planetxyz = vec3(xproj*math.cos(longitude),
                xproj*math.sin(longitude),
                math.sin(latitude));
                return vec3(planet.center) + (planet.radius + altitude) * planetxyz
                end

                if databank_1.getStringValue(15) ~= "" then
                asteroidPOS = databank_1.getStringValue(15)
                else
                asteroidPOS = ''
                end
                GHUD_marker_name = "Asteroid" --export:
                GHUD_shield_auto_calibration = true --export: (AUTO/MANUAL) shield mode
                GHUD_shield_calibration_max = true --export: (MAX/50) calibration of the entire shield power by the largest resist based on DPS
                GHUD_departure_planet = 'Alioth' --export: Departure ID planet
                GHUD_destination_planet = 'Jago' --export: Destination ID planet
                GHUD_background_color = "#142027" --export: Background color
                GHUD_pipe_text_color = "#FFFFFF" --export: Pipe text color
                GHUD_pipe_Y = -0.1 --export:
                GHUD_pipe_X = 15.5 --export:
                GHUD_Y = 50 --export:
                GHUD_right_block_X = 30 --export:
                GHUD_left_block_X = 12 --export:
                collectgarbages = false --export: experimental

                if GHUD_marker_name == "" then GHUD_marker_name = "Asteroid" end
                asteroidcoord = {}
                if asteroidPOS ~= "" then
                asteroidcoord = zeroConvertToWorldCoordinates(asteroidPOS)
                else
                asteroidcoord = {0,0,0}
                end

                --icons
                local icons = {}
                function iconStatusCheck(status)
                if status == 'on' or status == 1 then
                return 'on'
                else
                return ''
                end
                end

                function icons.space(status)
                return [[<svg class="icon ]] .. iconStatusCheck(status) .. [[" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 197.6 107.43">
                <path class="a" d="M197.19,25.35c-4.31-15-38.37-12.36-60-9.09A53.64,53.64,0,0,0,46.29,42.48C26.28,51.21-3.9,67.12.42,82.08,2.81,90.36,14.68,93.74,31.3,93.74a197.4,197.4,0,0,0,29.09-2.56A53.64,53.64,0,0,0,151.31,65C179.87,52.59,200.82,37.94,197.19,25.35Zm-98.38-16A44.44,44.44,0,0,1,143.2,53.71,45.3,45.3,0,0,1,143,58.4a363,363,0,0,1-38.9,13.51,361.77,361.77,0,0,1-40,9.27A44.32,44.32,0,0,1,98.81,9.32ZM9.37,79.5c-.83-2.89,7.34-13.18,35.74-26.27,0,.16,0,.32,0,.48a53.27,53.27,0,0,0,8.58,29C26.33,86.24,10.55,83.58,9.37,79.5ZM98.81,98.11a44.13,44.13,0,0,1-26.65-9c11.34-2.18,23.07-5,34.47-8.28s22.84-7.12,33.6-11.31A44.43,44.43,0,0,1,98.81,98.11ZM152.5,54.2c0-.16,0-.32,0-.49a53.34,53.34,0,0,0-8.56-29c31-4.05,43.45.32,44.28,3.2C189.42,32,177.43,42.64,152.5,54.2Z" />
                </svg>
                ]]
                end

                function icons.marker(status)
                return [[<svg class="icon ]] .. iconStatusCheck(status) .. [[" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 148.21 197.07">
                <path class="a" d="M74.1,42.8a31.32,31.32,0,1,0,31.32,31.32A31.35,31.35,0,0,0,74.1,42.8Zm0,52A20.73,20.73,0,1,1,94.83,74.1,20.75,20.75,0,0,1,74.1,94.83Z" />
                <path class="a" d="M74.12,0A74.21,74.21,0,0,0,0,74.13c0,18.39,6.93,32.36,18.88,50.26,12.45,18.7,49.42,68.42,51,70.54a5.28,5.28,0,0,0,8.49,0c1.57-2.11,38.53-51.84,51-70.53,11.95-17.9,18.88-31.87,18.88-50.26A74.18,74.18,0,0,0,74.12,0Zm46.42,118.51c-9.84,14.77-36.1,50.4-46.42,64.36-10.33-14-36.59-49.59-46.43-64.36-12.78-19.15-17.1-30.35-17.1-44.39a63.53,63.53,0,1,1,127,0C137.64,88.16,133.32,99.36,120.54,118.51Z" />
                </svg>
                ]]
                end

                function icons.ship(status)
                return [[<svg class="icon ]] .. iconStatusCheck(status) .. [[" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 196.27 188.83">
                <path class="a" d="M183.91,132c-11.23-12.44-48.54-50.86-55.11-57.61V45.16C128.8,13.89,106.58,0,98.14,0S67.47,13.89,67.47,45.16V74.43C60.91,81.18,23.6,119.6,12.36,132-.2,146-.06,162.53,0,170.49v1.41a3.8,3.8,0,0,0,3.8,3.8H57.45a40.18,40.18,0,0,1-5.55,6.53,3.8,3.8,0,0,0,2.58,6.6H141.8a3.8,3.8,0,0,0,2.57-6.6,39.67,39.67,0,0,1-5.54-6.53h53.62a3.8,3.8,0,0,0,3.8-3.8v-1.41C196.33,162.53,196.47,146,183.91,132ZM98.14,7.61c3.91,0,23.06,10.23,23.06,37.55v90.08H75.08V45.16C75.08,17.84,94.22,7.61,98.14,7.61Zm8.8,135.23,7.14,38.39H82.19l7.14-38.39ZM7.61,168.1c0-7.87.84-20.37,10.4-31,9.31-10.31,36.81-38.75,49.46-51.79v60.27c0,7.76-2.34,15.68-5.64,22.48Zm67.47-22.48v-2.78H81.6l-7.14,38.39H62.86C69.54,172.09,75.08,158.76,75.08,145.62Zm46.73,35.6-7.14-38.38h6.53v2.78c0,13.14,5.53,26.47,12.22,35.6Zm12.64-13.12c-3.31-6.8-5.65-14.72-5.65-22.48V85.35c12.65,13,40.15,41.48,49.46,51.79,9.57,10.6,10.38,23.09,10.41,31Z" />
                </svg>
                ]]
                end

                function icons.player(status)
                return [[<svg class="icon ]] .. iconStatusCheck(status) .. [[" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 63.36 198">
                <circle class="a" cx="31.68" cy="17.82" r="17.82" />
                <path class="a" d="M43.56,41.58H19.8A19.86,19.86,0,0,0,0,61.38v45.54A19.85,19.85,0,0,0,11.88,125v57.12A15.89,15.89,0,0,0,27.72,198h7.92a15.89,15.89,0,0,0,15.84-15.84V125a19.85,19.85,0,0,0,11.88-18.12V61.38A19.86,19.86,0,0,0,43.56,41.58Z" />
                </svg>
                ]]
                end

                --debug coroutine
                function coroutine.xpcall(co)
                local output = {coroutine.resume(co)}
                if output[1] == false then
                local tb = traceback(co)

                local message = tb:gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk')
                system.print(message)

                message = output[2]:gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk')
                system.print(message)
                return false, output[2], tb
                end
                return table.unpack(output)
                end

                function calcDistance(origCenter, destCenter, location)
                local pipe = (destCenter - origCenter):normalize()
                local r = (location-origCenter):dot(pipe) / pipe:dot(pipe)
                if r <= 0. then
                return (location-origCenter):len()
                elseif r >= (destCenter - origCenter):len() then
                return (location-destCenter):len()
                end
                local L = origCenter + (r * pipe)
                pipeDistance =  (L - location):len()

                return pipeDistance
                end

                function calcDistanceStellar(stellarObjectOrigin, stellarObjectDestination, currenLocation)
                local origCenter = vec3(stellarObjectOrigin.center)
                local destCenter = vec3(stellarObjectDestination.center)

                return calcDistance(origCenter, destCenter, currenLocation)
                end

                function closestPipe()
                while true do
                local smallestDistance = nil;
                local nearestPlanet = nil;
                local i = 0
                for obj in pairs(stellarObjects) do
                    i = i + 1
                    if (stellarObjects[obj].type[1] == 'Planet' or stellarObjects[obj].isSanctuary == true) then
                        local planetCenter = vec3(stellarObjects[obj].center)
                        local distance = vec3(vec3(construct.getWorldPosition()) - planetCenter):len()

                        if (smallestDistance == nil or distance < smallestDistance) then
                            smallestDistance = distance;
                            nearestPlanet = obj;
                        end
                    end
                    if i > 30 then
                        i = 0
                        coroutine.yield()
                    end
                end
                i = 0
                closestPlanet = stellarObjects[nearestPlanet]
                nearestPipeDistance = nil
                nearestAliothPipeDistance= nil
                for obj in pairs(stellarObjects) do
                    if (stellarObjects[obj].type[1] == 'Planet' or stellarObjects[obj].isSanctuary == true) then
                        for obj2 in pairs(stellarObjects) do
                            i = i + 1
                            if (obj2 > obj and (stellarObjects[obj2].type[1] == 'Planet' or stellarObjects[obj2].isSanctuary == true)) then
                            pipeDistance = calcDistanceStellar(stellarObjects[obj], stellarObjects[obj2], vec3(construct.getWorldPosition()))
                            if nearestPipeDistance == nil or pipeDistance < nearestPipeDistance then
                                nearestPipeDistance = pipeDistance;
                                sortestPipeKeyId = obj;
                                sortestPipeKey2Id = obj2;
                            end
                            if stellarObjects[obj].name[1] == "Alioth" and (nearestAliothPipeDistance == nil or pipeDistance < nearestAliothPipeDistance) then
                                nearestAliothPipeDistance = pipeDistance;
                                sortestAliothPipeKeyId = obj;
                                sortestAliothPipeKey2Id = obj2;
                            end
                            end
                            closestPipeData.value = stellarObjects[sortestPipeKeyId].name[1] .. " - " .. stellarObjects[sortestPipeKey2Id].name[1]
                            --closestPipeDistData.value = string.format("%03.2f", nearestPipeDistance / 200000.0)
                            --closestAliothPipeData.value = stellarObjects[sortestAliothPipeKeyId].name[1] .. " - " .. stellarObjects[sortestAliothPipeKey2Id].name[1]
                            --closestAliothPipeDistData.value = string.format("%03.2f", nearestAliothPipeDistance / 200000.0)
                            if i > 30 then
                            i = 0
                            coroutine.yield()
                            end
                        end
                    end
                end
                end
                end

                --2D Planet radar and AR planets
                screenHeight = system.getScreenHeight()
                screenWidth = system.getScreenWidth()
                DisplayRadar = false
                function drawonradar(coordonate,PlaneteName)
                local constructUp = vec3(construct.getWorldOrientationUp())
                local constructForward = vec3(construct.getWorldOrientationForward())
                local constructRight = vec3(construct.getWorldOrientationRight())
                local ConstructWorldPos = vec3(construct.getWorldPosition())
                local ToCible=coordonate-ConstructWorldPos
                local Xcoord = mySignedAngleBetween(ToCible, constructForward, constructUp)/math.pi --*RadarR
                local Ycoord = mySignedAngleBetween(ToCible, constructForward, constructRight)/math.pi --*RadarR+RadarY
                local XcoordR=Xcoord*math.sqrt(1-Ycoord*Ycoord/2)*RadarR+RadarX
                local YcoordR=Ycoord*math.sqrt(1-Xcoord*Xcoord/2)*RadarR+RadarY
                svgradar=svgradar..string.format([[
                <circle cx="%f" cy="%f" r="4" fill="red" />
                <text x="%f" y="%f" font-size="12px" fill="yellow">%s</text>
                ]],XcoordR,YcoordR,XcoordR+4,YcoordR,PlaneteName)
                end

                function mySignedAngleBetween(vecteur1, vecteur2, planeNormal)

                local normVec1 = vecteur1:project_on_plane(planeNormal):normalize()
                local normVec2 = vecteur2:normalize()

                local angle = math.acos(normVec1:dot(normVec2))
                local crossProduct = vecteur1:cross(vecteur2)

                if crossProduct:dot(planeNormal) < 0 then
                return -angle
                else
                return angle
                end
                end

                function getClosestPlanet(wp)
                local ClosestPlanet={}
                ClosestPlanet.distance=999999999999
                for BodyId in pairs(atlas[0]) do
                local planet=atlas[0][BodyId]
                local distance=(vec3(planet.center)-wp):len()
                if math.min(ClosestPlanet.distance,distance)==distance then
                    ClosestPlanet.name=planet.name[1]
                    ClosestPlanet.distance=distance
                end
                end
                return planet
                end

                function getClosestPlanet1(wp)
                local ClosestPlanet={}
                ClosestPlanet.distance=999999999999
                for BodyId in pairs(atlas[0]) do
                local planet=atlas[0][BodyId]
                local distance=(vec3(planet.center)-wp):len()
                if math.min(ClosestPlanet.distance,distance)==distance then
                    ClosestPlanet.name=planet.name[1]
                    ClosestPlanet.distance=distance
                end
                end
                return ClosestPlanet.name,ClosestPlanet.distance
                end

                function getClosestPipe1(wp,startLocation)
                local ClosestPlanet={}
                ClosestPlanet.pipedistance=999999999999
                for BodyId in pairs(atlas[0]) do
                local stopLocation=atlas[0][BodyId]
                local pipe=vec3(startLocation.center) - vec3(stopLocation.center)
                local pipedistance=(wp - vec3(startLocation.center)):project_on_plane(pipe):len()
                if math.min(ClosestPlanet.pipedistance,pipedistance)==pipedistance and (vec3(startLocation.center)-wp):len()<pipe:len() and (vec3(stopLocation.center)-wp):len()<pipe:len() then
                    ClosestPlanet.pipename=stopLocation.name[1]
                    ClosestPlanet.pipedistance=pipedistance
                end
                end
                return ClosestPlanet.pipename, ClosestPlanet.pipedistance
                end

                function getSafeZoneDistance(wp)
                local CenterSafeZone = vec3(13771471, 7435803, -128971)
                local distance=math.floor(((wp-CenterSafeZone):len()-18000000))
                return distance
                end

                playerName = system.getPlayerName(player.getId())
                xDelta = -238
                yDelta = -108
                mapScale = .99999
                planetScale = 1200
                aliothsize = 8000
                moonScale = 3000
                map = 0
                warpScan = 0
                targetList = ''
                altb=false
                safew=''
                varcombat = core.getPvPTimer()
                function pD()
                local pipeD = ''
                if nearestPipeDistance >= 100000 then
                pipeD = ''..string.format('%0.2f', nearestPipeDistance/200000)..' su'
                elseif nearestPipeDistance >= 1000 and nearestPipeDistance < 100000 then
                pipeD = ''..string.format('%0.1f', nearestPipeDistance/1000)..' km'
                else
                pipeD = ''..string.format('%0.0f', nearestPipeDistance)..' m'
                end
                if nearestPipeDistance >= 600000 then
                return closestPipeData.value.. '<br>' .. '<green1>'..pipeD..'</green1>'
                elseif nearestPipeDistance >= 400000 and nearestPipeDistance <= 600000 then
                return closestPipeData.value.. '<br>' .. '<orange1>'..pipeD..'</orange1>'
                elseif nearestPipeDistance < 400000 then
                return closestPipeData.value.. '<br>' .. '<red1>'..pipeD..'<red1>'
                end
                end

                shipName = construct.getName()
                conID = tostring(construct.getId()):sub(-3)
                bhelper = false
                system.showHelper(0)
                distS = ''
                safetext=''
                szsafe=true
                tz1=0
                tz2=0

                function indexSort(tbl)
                local idx = {}
                for i = 1, #tbl do idx[i] = i end
                table.sort(idx, function(a, b) return tbl[a] > tbl[b] end)
                return (table.unpack or unpack)(idx)
                end

                function getResRatioBy2HighestDamage(stress)
                local resRatio = {0,0,0,0}
                local h1, h2 = indexSort(stress)
                if stress[h2] > 0 then
                resRatio[h1] = resMAX/2
                resRatio[h2] = resMAX/2
                else
                resRatio[h1] = resMAX
                end
                return resRatio
                end

                safeStatus = ''
                safeVector = 0
                lalt=false
                buttonC=false
                buttonSpace=false
                resMAX = shield.getResistancesPool()
                function getRes(stress, resMAX)
                local res = {0.15,0.15,0.15,0.15}
                if stress[1] >= stress[2] and
                stress[1] >= stress[3] and
                stress[1] > stress[4] then
                res = {resMAX,0,0,0}
                elseif stress[2] >= stress[1] and
                stress[2] >= stress[3] and
                stress[2] > stress[4] then
                    res = {0,resMAX,0,0}
                elseif stress[3] >= stress[1] and
                    stress[3] >= stress[2] and
                    stress[3] > stress[4] then
                        res = {0,0,resMAX,0}
                    elseif stress[4] >= stress[1] and
                        stress[4] >= stress[2] and
                        stress[4] > stress[3] then
                            res = {0,0,0,resMAX}
                        else
                            system.print("ERR1")
                            system.playSound('shieldResistError.mp3')
                        end
                        return res
                    end
                    shoteCount = 0
                    lastShotTime = system.getTime()
                    resCLWN = ""
                    if GHUD_shield_auto_calibration
                    then
                        if GHUD_shield_calibration_max then
                            shieldText = "SHIELD (AUTO,MAX)"
                        end
                        if not GHUD_shield_calibration_max then
                            shieldText = "SHIELD (AUTO,50)"
                        end
                    else
                        if GHUD_shield_calibration_max then
                            shieldText = "SHIELD (MANUAL,MAX)"
                        end

                        if not GHUD_shield_calibration_max then
                            shieldText = "SHIELD (MANUAL,50)"
                        end
                    end

                    brakeText = ""
                    if shield.isActive() == 0 then
                        shieldColor = "#fc033d"
                        shieldStatus = "ACTIVE"
                    else
                        shieldColor = "#2ebac9"
                        shieldStatus = "DEACTIVE"
                    end

                    resisttime = 0
                    venttime = 0
                    venttimemax = shield.getVentingMaxCooldown()
                    resisttimemax = shield.getResistancesMaxCooldown()

                    for BodyId in pairs(atlas[0]) do
                        local planet=atlas[0][BodyId]
                        if planet.name[1] == GHUD_destination_planet then
                            DestinationCenter = vec3(planet.center)
                            DestinationCenterName = planet.name[1]
                        end
                        if planet.name[1] == GHUD_departure_planet then
                            DepartureCenter = vec3(planet.center)
                            DepartureCenterName = planet.name[1]
                        end
                    end

                    mybr=false
                    --needs redesign
                    html1 = [[
                    <style>
                    .main1 {
                        position: fixed;
                        width: 11em;
                        padding: 1vh;
                        top: 1vh;
                        left: 50%;
                        transform: translateX(-50%);
                        text-align: center;
                        background: #142027;
                        color: white;
                        font-family: "Lucida" Grande, sans-serif;
                        font-size: 1.5em;
                        border-radius: 5vh;
                        border: 0.2vh solid;
                        border-color: #fca503;
                        </style>
                        <div class="main1">BRAKE ENGAGED</div>]]
                        dis=0
                        accel=0
                        resString = ""
                        throttle1=0
                        fuel1=0

                        blink=1
                        shieldAlarm = false
                        alarmTimer = false
                        t2=nil
                        coratinka=0

                        -- прибавляет к вектору, из двух координат, кусочек длины
                        -- и воозращает координату окончания вектора, с учетом прибалвенной длины
                        function vectorLengthen(coordinateBegin, coordinateEnd, deltaLen)
                            local vector = makeVector(coordinateBegin, coordinateEnd)
                            --длина вектора
                            local lenVector = vec3(vector):len()
                            -- новая длина вектора
                            local newLen = lenVector + deltaLen
                            local factor = newLen / lenVector
                            --новый вектор с удлиненной координатой
                            local newVector = vector * factor
                            -- надо прибавить к первой начальной координате полученый вектор
                            local x = vec3(coordinateBegin).x + vec3(newVector).x
                            local y = vec3(coordinateBegin).y + vec3(newVector).y
                            local z = vec3(coordinateBegin).z + vec3(newVector).z
                            -- итого координата окончания удлиненного вектора
                            local resultCoordinate = vec3(x, y, z)
                            return resultCoordinate
                        end

                        function customDistance(distance)
                            local distanceS=''
                            if distance < 1000 then
                            distanceS = ''..string.format('%0.0f', distance)..' m'
                            elseif distance < 100000 then
                            distanceS = ''..string.format('%0.1f', distance/1000)..' km'
                            else
                            distanceS = ''..string.format('%0.2f', distance/200000)..' su'
                            end
                            return distanceS
                        end

                        local function signedAngleBetween(vec1, vec2, planeNormal)
                            local normVec1 = vec1:normalize()
                            local normVec2 = vec2:normalize()
                            local cosAngle = normVec1:dot(normVec2)
                            cosAngle = utils.clamp(cosAngle, -1, 1)
                            local angle = math.acos(cosAngle)
                            local crossProduct = vec1:cross(vec2)
                            if crossProduct:dot(planeNormal) < 0 then
                            return -angle - math.pi
                            else
                            return angle + math.pi
                            end
                        end
                        local function directionToBearing (direction, worldVertical)
                            local north = vec3(0, 0, 1)
                            local northOnGround = north:project_on_plane(worldVertical)
                            local directionOnGround = direction:project_on_plane(worldVertical)
                            return signedAngleBetween(northOnGround, directionOnGround, worldVertical)
                        end
                        function rotateX3D(point, theta)
                            theta = theta * math.pi / 180
                            local sinTheta = math.sin(theta);
                            local cosTheta = math.cos(theta);
                            local y = point.y * cosTheta - point.z * sinTheta
                            local z = point.z * cosTheta + point.y * sinTheta
                            point.y = y
                            point.z = z
                            return point
                        end
                        function rotateY3D(point, theta)
                            theta = theta * math.pi / 180
                            local sinTheta = math.sin(theta);
                            local cosTheta = math.cos(theta);
                            local x = point.x * cosTheta - point.y * sinTheta
                            local y = point.y * cosTheta + point.x * sinTheta
                            point.x = x
                            point.y = y
                            return point
                        end
                        function rotateZ3D(point, theta)
                            theta = theta * math.pi / 180
                            local sinTheta = math.sin(theta);
                            local cosTheta = math.cos(theta);
                            local x = point.x * cosTheta + point.z * sinTheta
                            local z = point.z * cosTheta - point.x * sinTheta
                            point.x = x
                            point.y = y
                            return point
                        end

                        --3D galaxy map
                        function drawMap()
                            local asteroid=""
                            local planet=""
                            local asterunits=""
                            local asternumbers=""
                            local galaxyMap = ''

                            galaxyMap = [[
                            <div class="system-map">
                            <div class="map-actual" style="transform: perspective(1920px) translateZ(-250px);">
                            <div class="map-center" style="transform: translate(-50%, -50%) rotateX(]]..yDelta..[[deg) rotateY(0deg) rotateZ(]]..xDelta..[[deg);"></div>
                            ]]

                            for BodyId in pairs(stellarObjects) do
                            --local planetBody = helios[v.bodyId]
                            local v = stellarObjects[BodyId]
                            local planetName = v.name[1]
                            local typeplanet = v.type[1]
                            local center = vec3(v.center)
                            local distance = customDistance(vec3(vec3(construct.getWorldPosition()) - vec3(v.center)):len())

                            local coords = {x=center.x + (-center.x * mapScale), y=center.y + (-center.y * mapScale), z=center.z + (-center.z * mapScale)}
                            rotateY3D(coords, xDelta)
                            rotateX3D(coords, yDelta)
                            local mainPlanet = true;
                            local size = planetScale

                            if vec3(vec3(construct.getWorldPosition()) - vec3(v.center)):len() > 12000000 then
                                size = planetScale
                            else
                                size = aliothsize
                            end
                            local display = "block"
                            if typeplanet ~= 'Planet' then
                                size = moonScale
                                display = "none"
                            end

                            local planet = [[
                            <div class="map-pin" style="display: ]]..display..[[; transform: translate(-50%, -50%) translateX(]]..coords.x..[[px) translateY(]]..coords.y..[[px) translateZ(]]..coords.z..[[px);">
                            <div class="pin-data" style="display: ]]..display..[[;">
                            <div class="name">]]..planetName..[[</div>
                            <div class="units">]]..distance..[[</div>
                            </div>
                            <div class="planet" style="width: ]]..(v.radius/size)..[[px; height: ]]..(v.radius/size)..[[px;"></div>
                            </div>
                            ]]

                            galaxyMap = galaxyMap .. planet
                            end

                            local shipPosition = construct.getWorldPosition()
                            local shipCoords = {x=shipPosition[1] + (-shipPosition[1] * mapScale), y=shipPosition[2] + (-shipPosition[2] * mapScale), z=shipPosition[3] + (-shipPosition[3] * mapScale)}
                            rotateY3D(shipCoords, xDelta)
                            rotateX3D(shipCoords, yDelta)

                            local playerPosition = [[
                            <div class="map-pin player" style="transform: translate(-50%, -50%) translateX(]]..shipCoords.x..[[px) translateY(]]..shipCoords.y..[[px) translateZ(]]..shipCoords.z..[[px);">
                            <div class="pin-data">
                            <div class="name"></div>
                            </div>
                            ]]..icons.player()..[[
                            </div>
                            ]]
                            galaxyMap = galaxyMap.. playerPosition

                            if asteroidPOS ~= "" then
                            local aPosition = asteroidcoord
                            local distance = customDistance(vec3(aPosition - vec3(construct.getWorldPosition())):len())
                            local asteroidC = {x=aPosition.x + (-aPosition.x * mapScale), y=aPosition.y + (-aPosition.y * mapScale), z=aPosition.z + (-aPosition.z * mapScale)}
                            rotateY3D(asteroidC, xDelta)
                            rotateX3D(asteroidC, yDelta)
                            local asteroid = [[
                            <div class="map-pin" style="transform: translate(-50%, -50%) translateX(]]..asteroidC.x..[[px) translateY(]]..asteroidC.y..[[px) translateZ(]]..asteroidC.z..[[px);">
                            <div class="pin-data">
                            <div class="name">]]..GHUD_marker_name..[[</div>
                            <div class="units">]]..distance..[[</div>
                            </div>
                            <div class="warp-scan"></div>
                            </div>
                            ]]
                            galaxyMap = galaxyMap..asteroid..'</div></div>'
                            end
                            galaxyMap = galaxyMap .. '</div></div>'

                            return galaxyMap
                        end

                        mapGalaxy = [[
                        <style>
                        .system-map {
                            position: absolute;
                            top: 0;
                            width: 100%;
                            height: 100%;
                            background: rgba(7, 44, 82, .81);
                            left: 0;
                        }
                        .planet {
                            width: 20px;
                            height: 20px;
                            border-radius: 50%;
                            border: 2px solid;
                            box-sizing: border-box;
                            background: rgba(148, 206, 255, .29);
                        }
                        .map-actual {
                            position: absolute;
                            width: 100%;
                            height: 100%;
                            top: 0;
                            left: 0;
                            transform-style: preserve-3d;
                        }
                        .map-center {
                            position: absolute;
                            content: '';
                            width: 2000px;
                            height: 2000px;
                            top: 50%;
                            left: 50%;
                            background: repeating-radial-gradient(rgba(0, 17, 35, .23), transparent 112px), repeating-radial-gradient(rgba(148, 206, 255, .34), transparent 75%);
                            border-radius: 50%;
                        }
                        .map-pin {
                            position: absolute;
                            top: 50%;
                            left: 50%;
                        }
                        .map-pin .icon,
                        .map-pin .planet {
                            height: 30px;
                            width: 30px;
                        }
                        .pin-data {
                            position: absolute;
                            bottom: 100%;
                            margin-bottom: 10px;
                            white-space: nowrap;
                            text-align: center;
                            width: 200px;
                            left: 50%;
                            transform: translateX(-50%);
                        }
                        .pin-data .name {
                            font-size: 16px;
                            color: white;
                            line-height: 16px;
                        }
                        .pin-data .units {
                            font-family: monospace;
                            font-size: 14px;
                            font-weight: bold;
                            line-height: 14px;
                        }
                        .map-pin.player {
                            filter: drop-shadow(0px 0px 20px #edf7ff);
                        }
                        .map-pin.player .icon {
                            fill: #ffde56;
                        }
                        .con-size {
                            width: 20px;
                            text-align: center;
                            background: #235f92;
                            margin-right: 4px;
                            color: white;
                            height: 18px;
                        }
                        .warp-scan {
                            width: 15px;
                            height: 15px;
                            border-radius: 50%;
                            box-sizing: border-box;
                            background: #ff3a56;
                        }
                        </style>]]

                        main1 = coroutine.create(closestPipe)

                        transponder.deactivate() --transponder server bug fix
                        unit.setTimer('tr',2)
                        unit.setTimer('hud',0.02)
                        unit.setTimer('prealarm',2)
                        if collectgarbages == true then
                            unit.setTimer("cleaner",30)
                        end
        onTimer:
            args: ['hud']
            lua: |
                if coroutine.status(main1) ~= "dead" and coroutine.status(main1) == "suspended" then
                coroutine.resume(main1)
                --coroutine.xpcall(main1) -- resume debug coroutine
                end

                damage_SVG()

                local stress = shield.getStressRatioRaw()
                AM_stress = stress[1]
                EM_stress = stress[2]
                KI_stress = stress[3]
                TH_stress = stress[4]

                ccs_SVG()

                local HP = shield.getShieldHitpoints()/shieldMaxHP * 100
                local formatted_hp = string.format('%0.0f',math.ceil(HP))

                if shield.isActive() == 0 then
                svghp = maxSHP * (HP*0.01)
                end

                if (system.getTime() - lastShotTime) >= 40 then
                shoteCount = 0
                end

                varcombat = core.getPvPTimer()

                resisttime = shield.getResistancesCooldown()
                if resisttime ~= 0 then
                if resisttime < resisttimemax  then
                    resCLWN = math.floor(resisttime)
                end
                else
                resCLWN = ""
                end
                if shield.isVenting() then
                venttime = shield.getVentingCooldown()
                if venttime < venttimemax and venttime ~= 0 then
                    resCLWN = math.floor(venttime)
                    shieldStatus = "VENTING"
                else
                    resCLWN = ""
                end
                end

                fuel_lvl = json.decode(spacefueltank_1.getWidgetData()).percentage
                ---
                local warningmsg = ''
                if math.ceil(HP) <= 50 then
                warningmsg = [[<style>
                .warningmsg {
                    position: fixed;
                    top: 25%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    width: 8em;
                    text-align: center;
                    background: #142027;
                    color: #fc033d;
                    font-family: verdana;
                    font-weight: bold;
                    font-size: 1.5em;
                    border-radius: 5vh;
                    border: 0.2vh solid;
                    border-color: #fca503;
                    </style>
                    <div class="warningmsg">SHIELD LOW!</div>]]
                end

                if t2 == true then
                    blink = blink + 0.015
                    if blink >= 1 then
                        t2=false
                    end
                end

                if t2 == false then
                    blink = blink - 0.015
                    if blink < 0.4 then
                        t2=true
                    end
                end

                if math.ceil(HP) <= 35 then
                    shieldAlarm=true
                    if alarmTimer == true then
                        warningmsg = [[<style>
                        .warningmsg {
                            position: fixed;
                            top: 25%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            width: 8em;
                            text-align: center;
                            background: #142027;
                            color: #fc033d;
                            opacity: ]]..blink..[[;
                            font-family: verdana;
                            font-weight: bold;
                            font-size: 1.5em;
                            border-radius: 5vh;
                            border: 0.2vh solid;
                            border-color: #fca503;
                            </style>
                            <div class="warningmsg">SHIELD LOW!</div>]]
                        end
                    else
                        shieldAlarm = false
                    end
                end
                local thrust1 = math.floor(unit.getThrottle())
                --brake distance
                local accel = math.floor((json.decode(unit.getWidgetData()).acceleration/9.80665)*10)/10
                local c = 8333.333
                local m0 = core.getConstructMass()
                local v0 = vec3(construct.getWorldVelocity())
                local speed = math.floor(v0):len() * 3.6)
                local maxSpeed = math.floor(construct.getMaxSpeed() * 3.6)
                local controllerData = json.decode(unit.getWidgetData())
                local maxBrakeThrust = controllerData.maxBrake
                local dis = 0.0
                local v = v0:len()
                while v>1.0 do
                    local m = m0 / (math.sqrt(1 - (v * v) / (c * c)))
                    local a = maxBrakeThrust / m
                    if v > a then
                        v = v - a --*1 sec
                        dis = dis + v + a / 2.0
                    elseif a ~= 0 then
                        local t = v/a
                        dis = dis + v * t + a*t*t/2
                        v = v - a
                    end
                end
                if dis > 100000 then
                    brakeDist = string.format(math.floor((dis/200000) * 10)/10)
                    brakeS = "SU"
                elseif dis > 1000 then
                    brakeDist = string.format(math.floor((dis/1000)*10)/10)
                    brakeS = "KM"
                else
                    brakeDist = string.format(math.floor(dis))
                    brakeS = "M"
                end
                --local closestPlanet = getClosestPlanet(shipPos)
                AR_planets = ''
                AR_asteroid = ''
                AR_pvpzone = ''
                AR_safezone = ''
                if DisplayRadar==true then
                    local x,y,z = table.unpack(construct.getWorldOrientationForward())
                    local xoc = math.floor(math.atan(x, y)*180/math.pi+180)
                    local yoc = math.floor(math.atan(y, z)*180/math.pi+180)
                    local XY = [[
                    <style>
                    .XY {
                        position: absolute;
                        left: 2%;
                        top: 26%;
                        color: #FFB12C;
                        font-size:18px;
                        font-family: verdana;
                        font-weight: bold;
                        text-align: left;
                    }</style>
                    <div class="XY">X: ]]..xoc..[[<br>Y: ]]..yoc..[[</div>]]
                    message=[[
                    <style>
                    .svg {
                        position:absolute;
                        left: 0;
                        top: 6vh;
                        height: 100vh;
                        width: 100vw;
                        .wptxt {
                            fill: white;
                            font-size: ]].. screenHeight/80 ..[[;
                            font-family: sans-serif;
                            text-anchor: end;
                            .shiptxt {
                            fill: white;
                            font-size: ]].. screenHeight/80 ..[[;
                            font-family: sans-serif;
                            text-anchor: start;
                            }
                            </style>]]
                            message=message..[[<svg class="svg">]]
                            svgradar=""
                            RadarX=screenWidth*1/6
                            RadarY=screenWidth*1/6
                            RadarR=screenWidth*1/6

                            svgradar=svgradar..string.format([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke-width="2" stroke="black" />]],RadarX,RadarY-RadarR,RadarX,RadarY+RadarR)
                            svgradar=svgradar..string.format([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke-width="2" stroke="black" />]],RadarX-RadarR,RadarY,RadarX+RadarR,RadarY)
                            svgradar=svgradar..string.format([[<circle  cx="%f" cy="%f" r="%f" stroke="black" fill="transparent" stroke-width="5"/>]],
                            RadarX,RadarY,RadarR/2)
                            svgradar=svgradar..string.format([[<circle  cx="%f" cy="%f" r="%f" stroke="black" fill-opacity="0.2" fill="green" stroke-width="5"/>]],
                            RadarX,RadarY,RadarR)

                            for BodyId in pairs(atlas[0]) do
                            local planet=atlas[0][BodyId]
                            if planet ~= closestPlanet then
                                if (planet.type[1] == 'Planet' or planet.isSanctuary == true) then
                                    drawonradar(vec3(planet.center),planet.name[1])
                                    local point1 = library.getPointOnScreen({planet.center.x,planet.center.y,planet.center.z})
                                    if point1[3] > 0 then --visible zone
                                        local dist = vec3(vec3(construct.getWorldPosition()) - vec3(planet.center)):len()
                                        local sdist = ''
                                        if dist >= 100000 then
                                        dist = string.format('%0.2f', dist/200000)
                                        sdist = 'SU'
                                        elseif dist >= 1000 and dist < 100000 then
                                        dist = string.format('%0.1f', dist/1000)
                                        sdist = 'KM'
                                        else
                                        dist = string.format('%0.0f', dist)
                                        sdist = 'M'
                                        end
                                        local x2 = screenWidth*point1[1] - 50
                                        local y2 = screenHeight*point1[2] - 50
                                        AR_planets = AR_planets .. [[
                                        <style>
                                        .pl]]..planet.name[1]..[[ {
                                        position: absolute;
                                        width: 100px;
                                        height: 100px;
                                        left: ]]..x2..[[px;
                                        top: ]]..y2..[[px;
                                        }
                                        </style>
                                        <div class="pl]]..planet.name[1]..[["><?xml version="1.0" encoding="utf-8"?>
                                        <svg viewBox="0 0 250 250" xmlns="http://www.w3.org/2000/svg">
                                        <ellipse style="fill: rgba(0, 0, 0, 0); stroke: #FFB12C; stroke-width: 8px;" cx="125" cy="125" rx="50" ry="50"/>
                                        <text style="fill: rgb(0, 191, 255); font-family: verdana; font-size: 28px; font-style: italic; font-weight: 700; text-anchor: middle;" x="125" y="48.955">]]..planet.name[1]..[[</text>
                                        <text style="fill: white; font-family: verdana; font-size: 28px; font-weight: 700; text-anchor: middle;" x="125" y="209.955">]]..dist..[[</text>
                                        <text style="fill: rgb(0, 191, 255); font-family: verdana; font-size: 28px; font-style: italic; font-weight: 700; text-anchor: middle;" x="125" y="240.424">]]..sdist..[[</text>
                                        </svg></div>]]
                                    end
                                end
                            end
                            end
                            drawonradar(safeWorldPos,"CENTRAL SZ")
                            if asteroidPOS ~= "" then
                            drawonradar(asteroidcoord,""..GHUD_marker_name.."")
                            local point1 = library.getPointOnScreen({asteroidcoord.x,asteroidcoord.y,asteroidcoord.z})
                            if point1[3] > 0 then --visible zone
                                local dist = vec3(vec3(construct.getWorldPosition()) - asteroidcoord):len()
                                local sdist = ''
                                if dist >= 100000 then
                                    dist = string.format('%0.2f', dist/200000)
                                    sdist = 'SU'
                                elseif dist >= 1000 and dist < 100000 then
                                    dist = string.format('%0.1f', dist/1000)
                                    sdist = 'KM'
                                else
                                    dist = string.format('%0.0f', dist)
                                    sdist = 'M'
                                end
                                local x2 = screenWidth*point1[1] - 50
                                local y2 = screenHeight*point1[2] - 50
                                AR_asteroid = [[
                                <style>
                                .marker]]..GHUD_marker_name..[[ {
                                    position: absolute;
                                    width: 100px;
                                    height: 100px;
                                    left: ]]..x2..[[px;
                                    top: ]]..y2..[[px;
                                }
                                </style>
                                <div class="marker]]..GHUD_marker_name..[["><?xml version="1.0" encoding="utf-8"?>
                                <svg viewBox="0 0 250 250" xmlns="http://www.w3.org/2000/svg">
                                <ellipse style="fill: rgba(0, 0, 0, 0); stroke: red; stroke-width: 8px;" cx="125" cy="125" rx="50" ry="50"/>
                                <text style="fill: rgb(0, 191, 255); font-family: verdana; font-size: 28px; font-style: italic; font-weight: 700; text-anchor: middle;" x="125" y="48.955">]]..GHUD_marker_name..[[</text>
                                <text style="fill: white; font-family: verdana; font-size: 28px; font-weight: 700; text-anchor: middle;" x="125" y="209.955">]]..dist..[[</text>
                                <text style="fill: rgb(0, 191, 255); font-family: verdana; font-size: 28px; font-style: italic; font-weight: 700; text-anchor: middle;" x="125" y="240.424">]]..sdist..[[</text>
                                </svg></div>]]
                            end
                            end --end asteroid
                            message=message..svgradar..XY
                            message=message.."</svg>"
                        else
                            message = ''
                        end

                        function safeZone()
                            local mabs = math.abs
                            local safeRadius = 18000000
                            local szradius = 500000
                            local distsz, distp = math.huge
                            local szsafe = false
                            local distsz = vec3(vec3(construct.getWorldPosition())):dist(safeWorldPos)
                            if distsz < safeRadius then
                            szsafe=true
                            distS = mabs(distsz - safeRadius)
                            local vector1 = vectorLengthen(safeWorldPos, vec3(construct.getWorldPosition()), distS)
                            if distS > 100000 then
                                distS = ''..string.format('%0.2f', distS/200000)..' su'
                            elseif distS > 1000 and distS < 100000 then
                                distS = ''..string.format('%0.1f', distS/1000)..' km'
                            else
                                distS = ''..string.format('%0.0f', distS)..' m'
                            end
                            --return 'PVP ZONE: '..distS..''
                            safeStatus = 'PVP ZONE: '..distS..''
                            safeVector = vector1
                            end

                            distp = vec3(construct.getWorldPosition()):dist(vec3(closestPlanet.center))
                            if distp < szradius then szsafe = true else szsafe = false end
                            if mabs(distp - szradius) < mabs(distsz - safeRadius) then
                            safew='::pos{0,0,'..closestPlanet.center.x..','..closestPlanet.center.y..','..closestPlanet.center.z..'}'
                            distS = mabs(distp - szradius)
                            local vector1 = vectorLengthen(vec3(closestPlanet.center), vec3(construct.getWorldPosition()), distS)
                            if distS > 100000 then
                                distS = ''..string.format('%0.2f', distS/200000)..' su'
                            elseif distS > 1000 and distS < 100000 then
                                distS = ''..string.format('%0.1f', distS/1000)..' km'
                            else
                                distS = ''..string.format('%0.0f', distS)..' m'
                            end
                            if szsafe == true then
                                --return ''..closestPlanet.name[1]..' PVP: '..distS..''
                                safeStatus = ''..closestPlanet.name[1]..' PVP: '..distS..''
                                safeVector = vector1
                            else
                                --return ''..closestPlanet.name[1]..' SAFE: '..distS..''
                                safeStatus = ''..closestPlanet.name[1]..' SAFE: '..distS..''
                                safeVector = vector1
                            end
                            else
                            distS = mabs(distsz - safeRadius)
                            local vector1 = vectorLengthen(safeWorldPos, vec3(construct.getWorldPosition()), distS)
                            if distS > 100000 then
                                distS = ''..string.format('%0.2f', distS/200000)..' su'
                            elseif distS > 1000 and distS < 100000 then
                                distS = ''..string.format('%0.1f', distS/1000)..' km'
                            else
                                distS = ''..string.format('%0.0f', distS)..' m'
                            end
                            --return 'SAFE ZONE: '..distS..''
                            safeStatus = 'SAFE ZONE: '..distS..''
                            safeVector = vector1
                            end
                        end
                        if szsafe == true then
                            safetext='<red1>'..safeStatus..'</red1>'
                            local point1 = library.getPointOnScreen({safeVector.x,safeVector.y,safeVector.z})
                            if point1[3] > 0 then --visible zone
                            local dist = vec3(vec3(construct.getWorldPosition()) - safeVector):len()
                            local sdist = ''
                            if dist >= 100000 then
                                dist = string.format('%0.2f', dist/200000)
                                sdist = 'SU'
                            elseif dist >= 1000 and dist < 100000 then
                                dist = string.format('%0.1f', dist/1000)
                                sdist = 'KM'
                            else
                                dist = string.format('%0.0f', dist)
                                sdist = 'M'
                            end
                            local x2 = screenWidth*point1[1] - 50
                            local y2 = screenHeight*point1[2] - 50
                            AR_pvpzone = [[
                            <style>
                            .pvpzoneAR {
                                position: absolute;
                                width: 100px;
                                height: 100px;
                                left: ]]..x2..[[px;
                                top: ]]..y2..[[px;
                            }
                            </style>
                            <div class="pvpzoneAR"><?xml version="1.0" encoding="utf-8"?>
                            <svg viewBox="0 0 250 250" xmlns="http://www.w3.org/2000/svg">
                            <ellipse style="fill: rgba(0, 0, 0, 0); stroke: #fc033d; stroke-width: 8px;" cx="125" cy="125" rx="50" ry="50"/>
                            <text style="fill: rgb(0, 191, 255); font-family: verdana; font-size: 28px; font-style: italic; font-weight: 700; text-anchor: middle;" x="125" y="48.955">PVP ZONE</text>
                            <text style="fill: white; font-family: verdana; font-size: 28px; font-weight: 700; text-anchor: middle;" x="125" y="209.955">]]..dist..[[</text>
                            <text style="fill: rgb(0, 191, 255); font-family: verdana; font-size: 28px; font-style: italic; font-weight: 700; text-anchor: middle;" x="125" y="240.424">]]..sdist..[[</text>
                            </svg></div>]]
                            end
                        else
                            safetext='<green1>'..safeStatus..'</green1>'
                            local point1 = library.getPointOnScreen({safeVector.x,safeVector.y,safeVector.z})
                            if point1[3] > 0 then --visible zone
                            local dist = vec3(vec3(construct.getWorldPosition()) - safeVector):len()
                            local sdist = ''
                            if dist >= 100000 then
                                dist = string.format('%0.2f', dist/200000)
                                sdist = 'SU'
                            elseif dist >= 1000 and dist < 100000 then
                                dist = string.format('%0.1f', dist/1000)
                                sdist = 'KM'
                            else
                                dist = string.format('%0.0f', dist)
                                sdist = 'M'
                            end
                            local x2 = screenWidth*point1[1] - 50
                            local y2 = screenHeight*point1[2] - 50
                            AR_safezone = [[
                            <style>
                            .safezoneAR {
                                position: absolute;
                                width: 100px;
                                height: 100px;
                                left: ]]..x2..[[px;
                                top: ]]..y2..[[px;
                            }
                            </style>
                            <div class="safezoneAR"><?xml version="1.0" encoding="utf-8"?>
                            <svg viewBox="0 0 250 250" xmlns="http://www.w3.org/2000/svg">
                            <ellipse style="fill: rgba(0, 0, 0, 0); stroke: #07e88e; stroke-width: 8px;" cx="125" cy="125" rx="50" ry="50"/>
                            <text style="fill: rgb(0, 191, 255); font-family: verdana; font-size: 28px; font-style: italic; font-weight: 700; text-anchor: middle;" x="125" y="48.955">SAFE ZONE</text>
                            <text style="fill: white; font-family: verdana; font-size: 28px; font-weight: 700; text-anchor: middle;" x="125" y="209.955">]]..dist..[[</text>
                            <text style="fill: rgb(0, 191, 255); font-family: verdana; font-size: 28px; font-style: italic; font-weight: 700; text-anchor: middle;" x="125" y="240.424">]]..sdist..[[</text>
                            </svg></div>]]
                            end
                        end

                        if coratinka==1 then
                            if coroutine.status(ck) ~= "dead" and coroutine.status(ck) == "suspended" then
                            coroutine.resume(ck)
                            end
                        end

                        local htmlHUD = [[
                        <html>
                        <style>
                        html,body {
                            margin:0;
                            padding:0;
                            overflow: hidden;
                        }
                        .shield1 {
                            position: absolute;
                            width: 1100px;
                            top: 89%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            filter: drop-shadow(0 0 25px blue);
                        }
                        .center1 {
                            position: relative;
                            margin-left: 50%;
                            margin-top: calc(50vh - 68px);
                            color: white;
                        }
                        .right1 {
                            color: rgb(0, 191, 255);
                            position: absolute;
                            left: 65%;
                            text-align:left;
                            font-size:18px;
                            font-family: verdana;
                            font-weight: bold;
                            text-shadow: 1px 0 1px #000,
                            0 1px 1px #000,
                            -1px 0 1px #000,
                            0 -1px 1px #000;
                        }
                        .thrust1 {
                            color: white;
                            position: absolute;
                            width: 100%;
                            display: flex;
                            font-size:20px;
                            justify-content: flex-end;
                            left: -101%;
                            margin-top: -1px;
                        }
                        .speed1 {
                            color: white;
                            position: absolute;
                            width: 100%;
                            display: flex;
                            font-size:20px;
                            justify-content: flex-end;
                            left: -101%;
                            margin-top: -1px;
                        }
                        .accel1 {
                            color: white;
                            position: absolute;
                            width: 100%;
                            display: flex;
                            font-size:20px;
                            justify-content: flex-end;
                            left: -101%;
                            margin-top: -1.5px;
                        }
                        .brakedist {
                            color: white;
                            position: absolute;
                            width: 100%;
                            display: flex;
                            font-size:20px;
                            justify-content: flex-end;
                            left: -101%;
                            margin-top: -1.5px;
                        }
                        .left1 {
                            color: rgb(0, 191, 255);
                            position: absolute;
                            right: 65%;
                            text-align: right;
                            font-size:18px;
                            font-family: verdana;
                            font-weight: bold;
                            text-shadow: 1px 0 1px #000,
                            0 1px 1px #000,
                            -1px 0 1px #000,
                            0 -1px 1px #000;
                        }
                        .shieldtext {
                            color: white;
                            position: absolute;
                            width: 100%;
                            display: flex;
                            justify-content: flex-end;
                            font-size:20px;
                            margin-left: -23px;
                            margin-top: -1px;
                        }
                        .fueltext {
                            color: white;
                            position: absolute;
                            width: 100%;
                            display: flex;
                            justify-content: flex-end;
                            font-size:20px;
                            margin-left: -23px;
                            margin-top: -1px;
                        }
                        .shield2 {
                            position: absolute;
                            margin-top: calc(-100% + 5px);
                            margin-left: 40%;
                            width: 120px;
                            height: 100px;
                        }
                        .fuel1 {
                            position: absolute;
                            margin-top:calc(-100% + 5px);
                            margin-left: 40%;
                            width: 120px;
                            height: 120px;
                        }
                        red1 {
                            color: #fc033d;
                        }
                        green1 {
                            color: #07e88e;
                        }
                        white1 {
                            color: white;
                        }
                        mspeed {
                            color: white;
                            opacity: 0.25;
                        }
                        blue1 {
                            color: rgb(0, 191, 255);
                        }
                        it {
                            font-style: italic;
                        }
                        orange1 {
                            color: #FFB12C;
                        }
                        .sight1 {
                            position: absolute;
                            width: 200px;
                            height: 200px;
                            left: 50%;
                            top: 50%;
                            transform: translate(-50%, -50%);
                        }
                        .sight2 {
                            position: absolute;
                            width: 400px;
                            height: 400px;
                            left: 50%;
                            top: 50%;
                            transform: translate(-50%, -50%);
                        }
                        .dotsight {
                            position: absolute;
                            width: 30px;
                            height: 30px;
                            left: 50%;
                            top: 50%;
                            transform: translate(-50%, -50%);
                        }
                        .safez {
                            width: auto;
                            padding: 2px;
                            position:fixed;
                            top:-0.1vh;
                            right:0;
                            text-align: right;
                            color: #FFFFFF;
                            font-size: 1.2em;
                            font-weight: bold;
                            background: ]]..GHUD_background_color..[[;
                            border: 0.2px solid black;
                        }
                        .pipe {
                            width: auto;
                            padding-left: 35px;
                            padding-right: 35px;
                            padding-top: 2px;
                            padding-bottom: 2px;
                            position:fixed;
                            top: ]]..GHUD_pipe_Y..[[vh;
                            right: ]]..GHUD_pipe_X..[[vw;
                            text-align: center;
                            color: ]]..GHUD_pipe_text_color..[[;
                            font-size: 1.2em;
                            font-weight: bold;
                            background: ]]..GHUD_background_color..[[;
                            border: 0.2px solid black;
                        }
                        </style>
                        <body>
                        ]]..warningmsg..[[
                        ]]..AR_asteroid..[[
                        ]]..AR_planets..[[
                        ]]..AR_pvpzone..[[
                        ]]..AR_safezone..[[
                        ]]..message..[[
                        <div class="safez">]]..safetext..[[</div>
                        <div class="pipe">]]..pD()..[[</div>
                        <div class="center1"></div>
                        <div class="right1"><it>THRUST</it><br><div class="thrust1">]]..thrust1..[[</div><orange1>%</orange1><br><it>SPEED</it><br><div class="speed1">]]..speed..[[</div><orange1>KM/H</orange1><mspeed> ]]..maxSpeed..[[</mspeed><br><it>ACCEL</it><br><div class="accel1">]]..accel..[[</div><orange1>G</orange1><br><it>BRAKE-DISTANCE</it><br><div class="brakedist">]]..brakeDist..[[</div><orange1>]]..brakeS..[[</orange1></div>
                        <div class="left1"><it>SHIELD</it><div class="shield2"><svg viewBox="0 0 100 100" fill="none" stroke="]]..shieldColor..[[" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" xmlns="http://www.w3.org/2000/svg">
                        <path d="M 50 60 C 50 60 58 56 58 50 L 58 43 L 50 40 L 42 43 L 42 50 C 42 56 50 60 50 60 Z"/>
                        </svg></div><br><div class="shieldtext">]]..formatted_hp..[[</div><orange1>%</orange1><br><it>FUEL</it><div class="fuel1"><svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                        <g fill="none" fill-rule="evenodd" transform="matrix(1, 0, 0, 1, -18, -4.5)">
                        <path d="M68 63c3.038 0 5.5-2.493 5.5-5.567 0-2.05-1.833-5.861-5.5-11.433-3.667 5.572-5.5 9.383-5.5 11.433C62.5 60.507 64.962 63 68 63z" fill="#FFB12C"/>
                        </g>
                        </svg></div><br><div class="fueltext">]]..fuel_lvl..[[</div><orange1>%</orange1></div>
                        <div class="shield1"><?xml version="1.0" encoding="utf-8"?>
                        <svg viewBox="0 0 500 500" xmlns="http://www.w3.org/2000/svg" xmlns:bx="https://boxy-svg.com">
                        <defs>
                        <linearGradient id="AM_gradient" x1="100%" x2="0%">
                        <stop stop-color="#fc033d" offset="]]..AM_svg..[[" />
                        <stop stop-color="rgb(15, 100, 212)" offset="0" />
                        </linearGradient>
                        <linearGradient id="EM_gradient" x1="100%" x2="0%">
                        <stop stop-color="#fc033d" offset="]]..EM_svg..[[" />
                        <stop stop-color="rgb(15, 100, 212)" offset="0" />
                        </linearGradient>
                        <linearGradient id="TH_gradient" x1="100%" x2="0%">
                        <stop stop-color="#fc033d" offset="]]..TH_svg..[[" />
                        <stop stop-color="rgb(15, 100, 212)" offset="0" />
                        </linearGradient>
                        <linearGradient id="KI_gradient" x1="100%" x2="0%">
                        <stop stop-color="#fc033d" offset="]]..KI_svg..[[" />
                        <stop stop-color="rgb(15, 100, 212)" offset="0" />
                        </linearGradient>
                        </defs>
                        <rect x="145" y="225" width="210" height="50" style="fill: #142027; stroke: rgb(15, 100, 212);" bx:origin="0.5 0.5"/>
                        <rect x="145" y="225" width="]]..svghp..[[" height="50" style="fill: rgb(15, 100, 212); stroke: rgb(15, 100, 212);" bx:origin="0.5 0.5"/>
                        ]]..damageLine..[[
                        ]]..ccsLineHit..[[
                        <rect x="180.2" y="220.2" width="]]..ccshp..[[" height="4.8" style="fill: white; stroke: white; stroke-width:0;"/>
                        <path style="fill: rgba(0, 0, 0, 0); stroke: rgb(66, 167, 245);" d="M 180.249 220.227 L 319.749 220.175 L 315.834 225 L 184.159 225 L 180.249 220.227 Z"/>
                        <rect x="180.2" y="275" width="]]..FUEL_svg..[[" height="4.8" style="fill: #FFB12C; stroke: #FFB12C; stroke-width:0;"/>
                        <path style="fill: rgba(0,0,0,0); stroke: rgb(66, 167, 245);" d="M 180.2 275.052 L 319.7 275 L 315.785 279.825 L 184.11 279.825 L 180.2 275.052 Z" transform="matrix(-1, 0, 0, -1, 499.900004, 554.825024)"/>
                        <path style="fill: url(#AM_gradient); stroke: ]]..AM_stroke_color..[[; stroke-width: ]]..AMstrokeWidth..[[;" d="M 125 215 L 185 250 L 95 250 L 85 240 L 125 215 Z" transform="matrix(-1, 0, 0, -1, 270.000006, 465.00001)"/>
                        <path style="fill: url(#TH_gradient); stroke: ]]..TH_stroke_color..[[; stroke-width: ]]..THstrokeWidth..[[;" d="M 315 225 L 325 215 L 415 215 L 355 250 L 315 225 Z"/>
                        <path style="fill: url(#KI_gradient); stroke: ]]..KI_stroke_color..[[; stroke-width: ]]..KIstrokeWidth..[[;" d="M 355 250 L 415 285 L 325 285 L 315 275 L 355 250 Z"/>
                        <path style="fill: url(#EM_gradient); stroke: ]]..EM_stroke_color..[[; stroke-width: ]]..EMstrokeWidth..[[;" d="M 85 260 L 95 250 L 185 250 L 125 285 L 85 260 Z" transform="matrix(-1, 0, 0, -1, 270.000006, 535.000011)"/>
                        <polygon style="fill: #142027; stroke: rgb(66, 167, 245); stroke-linejoin: round; stroke-linecap: round;" points="244 225 249 231 261 231 266 225"></polygon>
                        <polygon style="fill: #142027; stroke: rgb(66, 167, 245); stroke-linejoin: round; stroke-linecap: round;" points="242.71400451660156 259.74798583984375 247.71400451660156 265.74798583984375 267.714 265.748 272.7139892578125 259.74798583984375" transform="matrix(-1, 0, 0, -1, 512.713989, 534.747986)"></polygon>
                        <text style="fill: rgb(255, 252, 252); font-family: Arial, sans-serif; font-size: 4.5px; font-weight: 700; text-anchor: middle;" transform="matrix(1, 0, 0, 1, -1.542758, -0.533447)"><tspan x="256.796" y="230.112">]]..resCLWN..[[</tspan></text>
                        <text style="fill: rgb(255, 252, 252); font-family: Arial, sans-serif; font-size: 4px; font-weight: 700; text-anchor: middle;" x="255.048" y="273.416">]]..shieldStatus..[[</text>
                        <text style="fill: rgb(66, 167, 245); font-family: Arial, sans-serif; font-weight: bold; font-size: 3.2px;" x="252" y="223.591">CCS</text>
                        <polygon style="fill: #142027; stroke: rgb(66, 167, 245); stroke-linejoin: round; stroke-linecap: round;" points="240 279.8 244.77499389648438 285.8290100097656 264.7749938964844 285.8290100097656 270 279.79998779296875"></polygon>
                        <text style="fill: rgb(255, 252, 252); font-family: Arial, sans-serif; font-size: 4px; font-weight: 700; text-anchor: middle;" x="255.28" y="284.311">]]..avWapr..[[/]]..totalWarp..[[</text>
                        <text style="fill: rgb(66, 167, 245); font-family: Arial, sans-serif; font-weight: bold; font-size: 3.2px; " x="270.092" y="284.585" transform="matrix(1, 0, 0, 1, -1.440212, 0.330109)">CELLS</text>
                        <text style="fill: rgb(66, 167, 245); font-family: Arial, sans-serif; font-weight: bold; font-size: 3.2px; " x="232.452" y="284.303" transform="matrix(1, 0, 0, 1, -1.451996, 0.612091)">WARP</text>
                        <text style="fill: rgb(255, 252, 252); font-family: Arial, sans-serif; font-size: 16px; font-weight: 700; paint-order: stroke; stroke: rgb(0, 0, 0); stroke-width: 1.25px;" transform="matrix(1, 0, 0, 1, -0.542236, -41.161256)"><tspan x="351.543" y="319.558">KI</tspan></text>
                        <text style="fill: rgb(255, 252, 252); font-family: Arial, sans-serif; font-size: 16px; font-weight: 700; paint-order: stroke; stroke: rgb(0, 0, 0); stroke-width: 1.25px;" transform="matrix(1, 0, 0, 1, -4.542999, -86.161257)"><tspan x="351.543" y="319.558">TH</tspan></text>
                        <text style="fill: rgb(255, 252, 252); font-family: Arial, sans-serif; font-size: 16px; font-weight: 700; paint-order: stroke; stroke: rgb(0, 0, 0); stroke-width: 1.25px;" transform="matrix(1, 0, 0, 1, -219.543004, -41.161256)"><tspan x="351.543" y="319.558">EM</tspan></text>
                        <text style="fill: rgb(255, 252, 252); font-family: Arial, sans-serif; font-size: 16px; font-weight: 700; paint-order: stroke; stroke: rgb(0, 0, 0); stroke-width: 1.25px;" transform="matrix(1, 0, 0, 1, -219.543004, -86.161257)"><tspan x="351.543" y="319.558">AM</tspan></text>
                        <text style="fill: rgb(255, 252, 252); font-family: Arial, sans-serif; font-size: 20px; font-weight: 700; paint-order: stroke; stroke: rgb(0, 0, 0); stroke-width: 1.25px; text-anchor: middle;" transform="matrix(1, 0, 0, 1, -93.528017, -62.474306)"><tspan x="352" y="320">]]..formatted_hp..[[%</tspan></text>
                        ]]..AM_res..[[
                        ]]..EM_res..[[
                        ]]..KI_res..[[
                        ]]..TH_res..[[
                        </svg></div>
                        <div class="dotsight"><?xml version="1.0" encoding="utf-8"?>
                        <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                        <ellipse style="fill:rgba(255, 255, 255, 0.5); stroke:rgba(255, 255, 255, 0.5);" cx="50" cy="50" rx="6" ry="6"/>
                        </svg></div>
                        </body>
                        </html>]]

                        if map == 0 then system.setScreen(htmlHUD) end
        onTimer:
            args: ['tr']
            lua: |
                transponder.activate()
                unit.stopTimer('tr')
        onTimer:
            args: ['prealarm']
            lua: |
                if shieldAlarm == false then 
                    t2=nil
                    alarmTimer = false
                end
                if shieldAlarm == true and alarmTimer == false then
                alarmTimer = true
                t2=false
                end
        onTimer:
            args: ['AM']
            lua: |
                am = am + 2
                if am_x >= -50 then
                    am_x = am_x + 3
                end
                if am_x >= 0 then am_x = 0 end
                AM_res = [[
                    <g transform="matrix(1, 0, 0, 1, ]]..am_x..[[, 0)">
                    <rect x="82" y="199" width="45" height="12" style="stroke: black; stroke-width: 1.5px; fill: rgb(242, 166, 4);" rx="6"/>
                    <text style="fill: rgb(51, 51, 51); font-family: Arial, sans-serif; font-size: 7.87472px; font-weight: 700;" transform="matrix(0.831276, 0, 0, 0.88892, -62.084976, 26.864447)"><tspan x="179.08" y="202.948">ACTIVATED</tspan></text>
                </g>
                ]]
                if am >= 120 then
                    am_opacity = am_opacity - 0.01
                    AM_res = [[
                    <g opacity="]]..am_opacity..[[" transform="matrix(1, 0, 0, 1, 0, 0)">
                    <rect x="82" y="199" width="45" height="12" style="stroke: black; stroke-width: 1.5px; fill: rgb(242, 166, 4);" rx="6"/>
                    <text style="fill: rgb(51, 51, 51); font-family: Arial, sans-serif; font-size: 7.87472px; font-weight: 700;" transform="matrix(0.831276, 0, 0, 0.88892, -62.084976, 26.864447)"><tspan x="179.08" y="202.948">ACTIVATED</tspan></text>
                </g>
                ]]
                if am_opacity <= 0 then
                    am_opacity = 1
                    am = 0
                    am_x = -50
                    AM_res = ''
                    unit.stopTimer('AM')
                end
                end
        onTimer:
            args: ['EM']
            lua: |
                em = em + 2
                if em_x >= -50 then
                    em_x = em_x + 3
                end
                if em_x >= 0 then em_x = 0 end
                EM_res = [[
                <g transform="matrix(1, 0, 0, 1, ]]..em_x..[[, 90)">
                <rect x="82" y="199" width="45" height="12" style="stroke: black; stroke-width: 1.5px; fill: rgb(242, 166, 4);" rx="6"/>
                <text style="fill: rgb(51, 51, 51); font-family: Arial, sans-serif; font-size: 7.87472px; font-weight: 700; white-space: pre;" transform="matrix(0.831276, 0, 0, 0.88892, -62.084976, 26.864447)"><tspan x="179.08" y="202.948">ACTIVATED</tspan></text>
                </g>
                ]]
                if em >= 120 then
                    em_opacity = em_opacity - 0.01
                    EM_res = [[
                    <g opacity="]]..em_opacity..[[" transform="matrix(1, 0, 0, 1, 0, 90)">
                    <rect x="82" y="199" width="45" height="12" style="stroke: black; stroke-width: 1.5px; fill: rgb(242, 166, 4);" rx="6"/>
                    <text style="fill: rgb(51, 51, 51); font-family: Arial, sans-serif; font-size: 7.87472px; font-weight: 700; white-space: pre;" transform="matrix(0.831276, 0, 0, 0.88892, -62.084976, 26.864447)"><tspan x="179.08" y="202.948">ACTIVATED</tspan></text>
                    </g>
                ]]
                if em_opacity <= 0 then
                    em_opacity = 1
                    em = 0
                    em_x = -50
                    EM_res = ''
                    unit.stopTimer('EM')
                end
                end
        onTimer:
            args: ['TH']
            lua: |
                th = th + 2
                if th_x <= 339 then
                    th_x = th_x - 3
                end
                if th_x <= 289 then th_x = 289 end
                TH_res = [[
                <g transform="matrix(1, 0, 0, 1, ]]..th_x..[[, 0)">
                <rect x="82" y="199" width="45" height="12" style="stroke: black; stroke-width: 1.5px; fill: rgb(242, 166, 4);" rx="6"/>
                <text style="fill: rgb(51, 51, 51); font-family: Arial, sans-serif; font-size: 7.87472px; font-weight: 700; white-space: pre;" transform="matrix(0.831276, 0, 0, 0.88892, -62.084976, 26.864447)"><tspan x="179.08" y="202.948">ACTIVATED</tspan></text>
                </g>
                ]]
                if th >= 120 then
                    th_opacity = th_opacity - 0.01
                    TH_res = [[
                    <g opacity="]]..th_opacity..[[" transform="matrix(1, 0, 0, 1, 289, 0)">
                    <rect x="82" y="199" width="45" height="12" style="stroke: black; stroke-width: 1.5px; fill: rgb(242, 166, 4);" rx="6"/>
                    <text style="fill: rgb(51, 51, 51); font-family: Arial, sans-serif; font-size: 7.87472px; font-weight: 700; white-space: pre;" transform="matrix(0.831276, 0, 0, 0.88892, -62.084976, 26.864447)"><tspan x="179.08" y="202.948">ACTIVATED</tspan></text>
                    </g>
                ]]
                if th_opacity <= 0 then
                    th_opacity = 1
                    th = 0
                    th_x = 339
                    TH_res = ''
                    unit.stopTimer('TH')
                end
                end
        onTimer:
            args: ['KI']
            lua: |
                ki = ki + 2
                if ki_x <= 339 then
                    ki_x = ki_x - 3
                end
                if ki_x <= 289 then ki_x = 289 end
                EM_res = [[
                <g transform="matrix(1, 0, 0, 1, ]]..ki_x..[[, 90)">
                <rect x="82" y="199" width="45" height="12" style="stroke: black; stroke-width: 1.5px; fill: rgb(242, 166, 4);" rx="6"/>
                <text style="fill: rgb(51, 51, 51); font-family: Arial, sans-serif; font-size: 7.87472px; font-weight: 700; white-space: pre;" transform="matrix(0.831276, 0, 0, 0.88892, -62.084976, 26.864447)"><tspan x="179.08" y="202.948">ACTIVATED</tspan></text>
                </g>
                ]]
                if ki >= 120 then
                    ki_opacity = ki_opacity - 0.01
                    KI_res = [[
                    <g opacity="]]..ki_opacity..[[" transform="matrix(1, 0, 0, 1, 289, 90)">
                    <rect x="82" y="199" width="45" height="12" style="stroke: black; stroke-width: 1.5px; fill: rgb(242, 166, 4);" rx="6"/>
                    <text style="fill: rgb(51, 51, 51); font-family: Arial, sans-serif; font-size: 7.87472px; font-weight: 700; white-space: pre;" transform="matrix(0.831276, 0, 0, 0.88892, -62.084976, 26.864447)"><tspan x="179.08" y="202.948">ACTIVATED</tspan></text>
                    </g>
                ]]
                if ki_opacity <= 0 then
                    ki_opacity = 1
                    ki = 0
                    ki_x = 339
                    KI_res = ''
                    unit.stopTimer('KI')
                end
                end
        onTimer:
            args: ['warp']
            lua: |
                avWapr = warpdrive.getRequiredWarpCells()
                totalWarp = warpdrive.getAvailableWarpCells()
        onTimer:
            args: ['cleaner']
            lua: |
                collectgarbage("collect")
    construct:
        onPvPTimer(active):
            lua: |
                if active == 0 then
                    CCS = 0
                    ccshp1 = maxCCS * (CCS * 0.01)
                    ccshp = ccshp1
                    last_core_stress = 0
                    last_shield_hp = shieldMaxHP
                    HP = 100
                    svghp = maxSHP * (HP*0.01)
                end
    core:
        onStressChanged(stress):
            lua: |
                local stress = core.getCoreStress()
                if stress > last_core_stress then
                    local newstress = stress - last_core_stress
                    local stresschange = newstress/core.getmaxCoreStress()*100
                    CCS = stress/core.getmaxCoreStress() * 100
                    ccshp1 = maxCCS * (CCS * 0.01)
                    ccshit = maxCCS * (stresschange*0.01)
                    last_core_stress = stress
                    ccsLineHit = [[<rect x="180.2" y="220.2" width="]]..ccshp1..[[" height="4.8" style="fill: #de1656; stroke: rgba(0,0,0,0);"/>]]
                end
    shield:
        onAbsorbed(hitpoints, rawHitpoints):
            lua: |
                local shield_hp = shield.getShieldHitpoints()
                if shield_hp < last_shield_hp then
                HP = shield_hp/shieldMaxHP * 100
                --formatted_hp = string.format('%0.0f',math.ceil(HP))
                local hit = last_shield_hp - shield_hp
                local damage1 = hit/shieldMaxHP*100
                damage = maxSHP * (damage1*0.01)
                svghp = maxSHP * (HP*0.01)
                last_shield_hp = shield_hp
                --damageLine = [[<rect x="]].. svghp + 145 ..[[" y="225" width="]]..damage..[[" height="50" style="fill: #de1656; stroke: #de1656;" bx:origin="0.5 0.5"/>]]
                end

                lastShotTime = system.getTime()
                shoteCount = shoteCount + 1
                if shield.getResistancesCooldown() == 0 and shoteCount >= 5 and GHUD_shield_auto_calibration then
                local stress = shield.getStressRatioRaw()
                local resistance = shield.getResistances()
                local res = getRes(stress, resMAX)

                if GHUD_shield_calibration_max then
                    if resistance[1] == res[1] and
                    resistance[2] == res[2] and
                    resistance[3] == res[3] and
                    resistance[4] == res[4]then
                        --system.print("Максимальный стресс не изменился")
                    else
                        if shield.setResistances(res[1],res[2],res[3],res[4]) == 1 then
                            system.print("Shield power has been set to max stress")
                            actionRes(res)
                            system.playSound('shieldNewResists.mp3')
                        else
                            system.print("ERR2")
                            system.playSound('shieldResistError.mp3')
                        end
                    end
                else
                    local re1 = getResRatioBy2HighestDamage(stress)[1]
                    local re2 = getResRatioBy2HighestDamage(stress)[2]
                    local re3 = getResRatioBy2HighestDamage(stress)[3]
                    local re4 = getResRatioBy2HighestDamage(stress)[4]
                    if re1 == resistance[1] and
                    re2 == resistance[2] and
                    re3 == resistance[3] and
                    re4 == resistance[4] then
                        --system.print("2 максимальных стресса не изменились")
                    else
                        if shield.setResistances(re1,re2,re3,re4) == 1 then
                            system.print("Shield power has been split 50/50%")
                            actionRes(re)
                            system.playSound('shieldNewResists.mp3')
                        else
                            system.print("ERR3")
                            system.playSound('shieldResistError.mp3')
                        end
                    end
                end
                end
        onDown():
            lua: |
                last_shield_hp = 0
                svghp = maxSHP
                shield.startVenting()
                system.print("The shield is over, shield regeneration started!")
        onVenting(active, restoredHitpoints):
            lua: |
                if shield.isVenting() == 0 then
                    shield.activate()
                end
        onRestored():
            lua: |
                last_shield_hp = shieldMaxHP
                svghp = maxSHP * (100*0.01)
                system.print("SHIELD READY")
        onToggled(active):
            lua: |
                if shield.isActive() == 0 then 
                    shieldColor = "#fc033d"
                    shieldStatus = "ACTIVE"
                else 
                    shieldColor = "#2ebac9"
                    shieldStatus = "DEACTIVE"
                    local shield_hp = shield.getShieldHitpoints() 
                    last_shield_hp = shield_hp
                    HP = shield_hp/shieldMaxHP * 100
                    svghp = maxSHP * (HP*0.01)
                end
    system:
        onFlush:
            lua: |
                -- constants: use 'myvar = defaultValue --export: description' to expose the variable in context menu

                local pitchSpeedFactor = 0.8 --export: This factor will increase/decrease the player input along the pitch axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                local yawSpeedFactor =  1 --export: This factor will increase/decrease the player input along the yaw axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                local rollSpeedFactor = 1.5 --export: This factor will increase/decrease the player input along the roll axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local brakeSpeedFactor = 3 --export: When braking, this factor will increase the brake force by brakeSpeedFactor * velocity<br>Valid values: Superior or equal to 0.01
                local brakeFlatFactor = 1 --export: When braking, this factor will increase the brake force by a flat brakeFlatFactor * velocity direction><br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local autoRoll = false --export: [Only in atmosphere]<br>When the pilot stops rolling,  flight model will try to get back to horizontal (no roll)
                local autoRollFactor = 2 --export: [Only in atmosphere]<br>When autoRoll is engaged, this factor will increase to strength of the roll back to 0<br>Valid values: Superior or equal to 0.01

                local turnAssist = true --export: [Only in atmosphere]<br>When the pilot is rolling, the flight model will try to add yaw and pitch to make the construct turn better<br>The flight model will start by adding more yaw the more horizontal the construct is and more pitch the more vertical it is
                local turnAssistFactor = 2 --export: [Only in atmosphere]<br>This factor will increase/decrease the turnAssist effect<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local torqueFactor = 2 -- Force factor applied to reach rotationSpeed<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                -- validate params
                pitchSpeedFactor = math.max(pitchSpeedFactor, 0.01)
                yawSpeedFactor = math.max(yawSpeedFactor, 0.01)
                rollSpeedFactor = math.max(rollSpeedFactor, 0.01)
                torqueFactor = math.max(torqueFactor, 0.01)
                brakeSpeedFactor = math.max(brakeSpeedFactor, 0.01)
                brakeFlatFactor = math.max(brakeFlatFactor, 0.01)
                autoRollFactor = math.max(autoRollFactor, 0.01)
                turnAssistFactor = math.max(turnAssistFactor, 0.01)

                -- final inputs
                local finalPitchInput = pitchInput + system.getControlDeviceForwardInput()
                local finalRollInput = rollInput + system.getControlDeviceYawInput()
                local finalYawInput = yawInput - system.getControlDeviceLeftRightInput()
                local finalBrakeInput = brakeInput

                -- Axis
                local worldVertical = vec3(core.getWorldVertical()) -- along gravity
                local constructUp = vec3(construct.getWorldOrientationUp())
                local constructForward = vec3(construct.getWorldOrientationForward())
                local constructRight = vec3(construct.getWorldOrientationRight())
                local constructVelocity = vec3(construct.getWorldVelocity())
                local constructVelocityDir = vec3(construct.getWorldVelocity()):normalize()
                local currentRollDeg = getRoll(worldVertical, constructForward, constructRight)
                local currentRollDegAbs = math.abs(currentRollDeg)
                local currentRollDegSign = utils.sign(currentRollDeg)

                -- Rotation
                local constructAngularVelocity = vec3(construct.getWorldAngularVelocity())
                local targetAngularVelocity = finalPitchInput * pitchSpeedFactor * constructRight
                                                + finalRollInput * rollSpeedFactor * constructForward
                                                + finalYawInput * yawSpeedFactor * constructUp

                -- In atmosphere?
                if worldVertical:len() > 0.01 and unit.getAtmosphereDensity() > 0.0 then
                    local autoRollRollThreshold = 1.0
                    -- autoRoll on AND currentRollDeg is big enough AND player is not rolling
                    if autoRoll == true and currentRollDegAbs > autoRollRollThreshold and finalRollInput == 0 then
                        local targetRollDeg = utils.clamp(0,currentRollDegAbs-30, currentRollDegAbs+30);  -- we go back to 0 within a certain limit
                        if (rollPID == nil) then
                            rollPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range
                        end
                        rollPID:inject(targetRollDeg - currentRollDeg)
                        local autoRollInput = rollPID:get()

                        targetAngularVelocity = targetAngularVelocity + autoRollInput * constructForward
                    end
                    local turnAssistRollThreshold = 20.0
                    -- turnAssist AND currentRollDeg is big enough AND player is not pitching or yawing
                    if turnAssist == true and currentRollDegAbs > turnAssistRollThreshold and finalPitchInput == 0 and finalYawInput == 0 then
                        local rollToPitchFactor = turnAssistFactor * 0.1 -- magic number tweaked to have a default factor in the 1-10 range
                        local rollToYawFactor = turnAssistFactor * 0.025 -- magic number tweaked to have a default factor in the 1-10 range

                        -- rescale (turnAssistRollThreshold -> 180) to (0 -> 180)
                        local rescaleRollDegAbs = ((currentRollDegAbs - turnAssistRollThreshold) / (180 - turnAssistRollThreshold)) * 180
                        local rollVerticalRatio = 0
                        if rescaleRollDegAbs < 90 then
                            rollVerticalRatio = rescaleRollDegAbs / 90
                        elseif rescaleRollDegAbs < 180 then
                            rollVerticalRatio = (180 - rescaleRollDegAbs) / 90
                        end

                        rollVerticalRatio = rollVerticalRatio * rollVerticalRatio

                        local turnAssistYawInput = - currentRollDegSign * rollToYawFactor * (1.0 - rollVerticalRatio)
                        local turnAssistPitchInput = rollToPitchFactor * rollVerticalRatio

                        targetAngularVelocity = targetAngularVelocity
                                            + turnAssistPitchInput * constructRight
                                            + turnAssistYawInput * constructUp
                    end
                end

                -- Engine commands
                local keepCollinearity = 1 -- for easier reading
                local dontKeepCollinearity = 0 -- for easier reading
                local tolerancePercentToSkipOtherPriorities = 1 -- if we are within this tolerance (in%), we don't go to the next priorities

                -- Rotation
                local angularAcceleration = torqueFactor * (targetAngularVelocity - constructAngularVelocity)
                local airAcceleration = vec3(construct.getWorldAirFrictionAngularAcceleration())
                angularAcceleration = angularAcceleration - airAcceleration -- Try to compensate air friction
                Nav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)

                -- Brakes
                local brakeAcceleration = -finalBrakeInput * (brakeSpeedFactor * constructVelocity + brakeFlatFactor * constructVelocityDir)
                Nav:setEngineForceCommand('brake', brakeAcceleration)

                -- AutoNavigation regroups all the axis command by 'TargetSpeed'
                local autoNavigationEngineTags = ''
                local autoNavigationAcceleration = vec3()
                local autoNavigationUseBrake = false

                -- Longitudinal Translation
                local longitudinalEngineTags = 'thrust analog longitudinal'
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byThrottle) then
                    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(longitudinalEngineTags,axisCommandId.longitudinal)
                    Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration, keepCollinearity)
                elseif  (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. longitudinalEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + longitudinalAcceleration
                    if (Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal) == 0 or -- we want to stop
                        Nav.axisCommandManager:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal) < - Nav.axisCommandManager:getTargetSpeedCurrentStep(axisCommandId.longitudinal) * 0.5) -- if the longitudinal velocity would need some braking
                    then
                        autoNavigationUseBrake = true
                    end

                end

                -- Lateral Translation
                local lateralStrafeEngineTags = 'thrust analog lateral'
                local lateralCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.lateral)
                if (lateralCommandType == axisCommandType.byThrottle) then
                    local lateralStrafeAcceleration =  Nav.axisCommandManager:composeAxisAccelerationFromThrottle(lateralStrafeEngineTags,axisCommandId.lateral)
                    Nav:setEngineForceCommand(lateralStrafeEngineTags, lateralStrafeAcceleration, keepCollinearity)
                elseif  (lateralCommandType == axisCommandType.byTargetSpeed) then
                    local lateralAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. lateralStrafeEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + lateralAcceleration
                end

                -- Vertical Translation
                local verticalStrafeEngineTags = 'thrust analog vertical'
                local verticalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.vertical)
                if (verticalCommandType == axisCommandType.byThrottle) then
                    local verticalStrafeAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(verticalStrafeEngineTags,axisCommandId.vertical)
                    Nav:setEngineForceCommand(verticalStrafeEngineTags, verticalStrafeAcceleration, keepCollinearity, 'airfoil', 'ground', '', tolerancePercentToSkipOtherPriorities)
                elseif  (verticalCommandType == axisCommandType.byTargetSpeed) then
                    local verticalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. verticalStrafeEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + verticalAcceleration
                end

                -- Auto Navigation (Cruise Control)
                if (autoNavigationAcceleration:len() > constants.epsilon) then
                    if (brakeInput ~= 0 or autoNavigationUseBrake or math.abs(constructVelocityDir:dot(constructForward)) < 0.95)  -- if the velocity is not properly aligned with the forward
                    then
                        autoNavigationEngineTags = autoNavigationEngineTags .. ', brake'
                    end
                    Nav:setEngineForceCommand(autoNavigationEngineTags, autoNavigationAcceleration, dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)
                end

                -- Rockets
                Nav:setBoosterCommand('rocket_engine')
        onUpdate:
            lua: |
                Nav:update()
                if mybr then brakeInput = 1 end
        onActionStart:
            args: [gear]
            lua: |
                gearExtended = not gearExtended
                if gearExtended then
                    unit.deployLandingGears()
                else
                    unit.retractLandingGears()
                end
        onActionStart:
            args: [light]
            lua: |
                if unit.isAnyHeadlightSwitchedOn() == 1 then
                    unit.switchOffHeadlights()
                else
                    unit.switchOnHeadlights()
                end
                if databank_1.getStringValue(15) ~= "" then
                    local way = databank_1.getStringValue(15)
                    system.setWaypoint(way)
                end
        onActionStart:
            args: [forward]
            lua: |
                pitchInput = pitchInput - 1
                if buttonC==true and shield.getResistancesCooldown() == 0 then
                if shield.setResistances(0,0,resMAX/2,resMAX/2) == 1 then
                    system.print("CANNON PROFILE: 50%/50%")
                    local res = {1,1,1,1}
                    actionRes(res)
                    system.playSound('shieldNewResists.mp3')
                else
                    system.print("ERR6")
                    system.playSound('shieldResistError.mp3')
                end
                end
        onActionStop:
            args: [forward]
            lua: pitchInput = pitchInput + 1
        onActionStart:
            args: [backward]
            lua: |
                pitchInput = pitchInput + 1
                if buttonC==true and shield.getResistancesCooldown() == 0 then
                if shield.setResistances(resMAX/4,resMAX/4,resMAX/4,resMAX/4) == 1 then
                    system.print("UNIVERSAL PROFILE: 25%/25%/25%/25%")
                    local res = {1,1,1,1}
                    actionRes(res)
                    system.playSound('shieldNewResists.mp3')
                else
                    system.print("ERR6")
                    system.playSound('shieldResistError.mp3')
                end
                end
        onActionStop:
            args: [backward]
            lua: pitchInput = pitchInput - 1
        onActionStart:
            args: [left]
            lua: |
                rollInput = rollInput - 1
                if buttonSpace==true and shield.getResistancesCooldown() == 0 then
                if shield.setResistances(0,0,resMAX,0) == 1 then
                    system.print("KINETIC POWER: 100%")
                    local res = {0,0,1,0}
                    actionRes(res)
                    system.playSound('shieldNewResists.mp3')
                else
                    system.print("ERR6")
                    system.playSound('shieldResistError.mp3')
                end
                end
                if buttonC==true and shield.getResistancesCooldown() == 0 then
                if shield.setResistances(resMAX/2,resMAX/2,0,0) == 1 then
                    system.print("RAILGUN PROFILE: 50/50%")
                    local res = {1,1,0,0}
                    actionRes(res)
                    system.playSound('shieldNewResists.mp3')
                else
                    system.print("ERR6")
                    system.playSound('shieldResistError.mp3')
                end
                end
        onActionStop:
            args: [left]
            lua: rollInput = rollInput + 1
        onActionStart:
            args: [right]
            lua: |
                rollInput = rollInput + 1
                if buttonSpace==true and shield.getResistancesCooldown() == 0 then
                if shield.setResistances(0,0,0,resMAX) == 1 then
                    system.print("THERMIC POWER: 100%")
                    local res = {0,0,0,1}
                    actionRes(res)
                    system.playSound('shieldNewResists.mp3')
                else
                    system.print("ERR6")
                    system.playSound('shieldResistError.mp3')
                end
                end
                if buttonC==true and shield.getResistancesCooldown() == 0 then
                if shield.setResistances(resMAX/2,0,resMAX/2,0) == 1 then
                    system.print("MISSILE PROFILE: 50/50%")
                    local res = {1,0,1,0}
                    actionRes(res)
                    system.playSound('shieldNewResists.mp3')
                else
                    system.print("ERR6")
                    system.playSound('shieldResistError.mp3')
                end
                end
        onActionStop:
            args: [right]
            lua: rollInput = rollInput - 1
        onActionStart:
            args: [straferight]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, 1.0)
        onActionStop:
            args: [straferight]
            lua: Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, -1.0)
        onActionStart:
            args: [strafeleft]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, -1.0)
        onActionStop:
            args: [strafeleft]
            lua: Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, 1.0)
        onActionStart:
            args: [up]
            lua: |
                Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, 1.0)
                if tz1 ~= 2 then tz2=1 end
                if tz1 == 1 and tz2 == 1 then tz1=2 mybr = true end
                if altb==false then buttonSpace=true end
        onActionStop:
            args: [up]
            lua: |
                Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, -1.0)
                Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)
                buttonSpace=false
        onActionStart:
            args: [down]
            lua: |
                Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, -1.0)
                if altb==false then buttonC=true end
        onActionStop:
            args: [down]
            lua: |
                Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, 1.0)
                Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)
                buttonC=false
        onActionStart:
            args: [groundaltitudeup]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(1.0)
        onActionLoop:
            args: [groundaltitudeup]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(1.0)
        onActionStart:
            args: [groundaltitudedown]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(-1.0)
        onActionLoop:
            args: [groundaltitudedown]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(-1.0)
        onActionStart:
            args: [yawright]
            lua: |
                yawInput = yawInput - 1
                if buttonSpace==true and shield.getResistancesCooldown() == 0 then
                if shield.setResistances(0,resMAX,0,0) == 1 then
                    system.print("ELECTROMAGNETIC POWER: 100%")
                    local res = {0,1,0,0}
                    actionRes(res)
                    system.playSound('shieldNewResists.mp3')
                else
                    system.print("ERR6")
                    system.playSound('shieldResistError.mp3')
                end
                end
                if buttonC==true and shield.getResistancesCooldown() == 0 then
                if shield.setResistances(0,resMAX/2,0,resMAX/2) == 1 then
                    system.print("LASER PROFILE: 50%/50%")
                    local res = {0,1,0,01}
                    actionRes(res)
                    system.playSound('shieldNewResists.mp3')
                else
                    system.print("ERR6")
                    system.playSound('shieldResistError.mp3')
                end
                end
        onActionStop:
            args: [yawright]
            lua: yawInput = yawInput + 1
        onActionStart:
            args: [yawleft]
            lua: | 
                yawInput = yawInput + 1
                if buttonSpace==true and shield.getResistancesCooldown() == 0 then
                if shield.setResistances(resMAX,0,0,0) == 1 then
                    system.print("ANTIMATTER POWER: 100%")
                    local res = {1,0,0,0}
                    actionRes(res)
                    system.playSound('shieldNewResists.mp3')
                else
                    system.print("ERR6")
                    system.playSound('shieldResistError.mp3')
                end
                end
                if buttonC==true and shield.getResistancesCooldown() == 0 then
                if shield.setResistances(0,resMAX/3,resMAX/3,resMAX/3) == 1 then
                    system.print("LASER/CANNON PROFILE: 33%/33%/33%")
                    local res = {0,1,1,1}
                    actionRes(res)
                    system.playSound('shieldNewResists.mp3')
                else
                    system.print("ERR6")
                    system.playSound('shieldResistError.mp3')
                end
                end
        onActionStop:
            args: [yawleft]
            lua: yawInput = yawInput - 1
        onActionStart:
            args: [brake]
            lua: |
                if tz1 ~= 2 then
                    brakeInput = brakeInput + 1
                    local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                    if (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
                    if (math.abs(targetSpeed) > constants.epsilon) then
                        Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, - utils.sign(targetSpeed))
                    end
                    end
                    mybr=true
                    tz1=1
                end
                if tz1 == 2 and tz2 == 1 then tz2=0 tz1=0 mybr = false end
        onActionStop:
            args: [brake]
            lua: | 
                brakeInput = brakeInput - 1
                if tz1==1 then tz1=0 mybr = false end
        onActionLoop:
            args: [brake]
            lua: |
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
                    if (math.abs(targetSpeed) > constants.epsilon) then
                        Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, - utils.sign(targetSpeed))
                    end
                end
        onActionStart:
            args: [booster]
            lua: Nav:toggleBoosters()
        onActionStart:
            args: [stopengines]
            lua: Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
        onActionStart:
            args: [speedup]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, 5.0)
        onActionLoop:
            args: [speedup]
            lua: Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, 1.0)
        onActionStart:
            args: [speeddown]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, -5.0)
        onActionLoop:
            args: [speeddown]
            lua: Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, -1.0)
        onActionStart:
            args: [antigravity]
            lua: if antigrav ~= nil then antigrav.toggle() end
        onActionStart:
            args: [option1]
            lua: |
                if lalt == false then Displayradar = not Displayradar end
        onActionStart:
            args: [option2]
            lua: |
                local DestWaypoint = "::pos{0,0," ..math.floor(DestinationCenter.x)..","..math.floor(DestinationCenter.y)..","..math.floor(DestinationCenter.z).."}"
                if lalt==false then
                system.print(DestinationCenterName)
                system.setWaypoint(DestWaypoint)
                else
                system.print(stellarObjects[sortestPipeKeyId].name[1])
                system.setWaypoint("::pos{0,0," ..math.floor(stellarObjects[sortestPipeKeyId].center.x).. "," ..math.floor(stellarObjects[sortestPipeKeyId].center.y).. "," ..math.floor(stellarObjects[sortestPipeKeyId].center.z).. "}")
                end
        onActionStart:
            args: [option3]
            lua: |
                if lalt==false then
                local function getPipeDistance()
                    local worldPos = shipPos
                    local pipe = (DestinationCenter - DepartureCenter):normalize()
                    local r = (worldPos -DepartureCenter):dot(pipe) / pipe:dot(pipe)
                    if r <= 0. then
                        return (worldPos-DepartureCenter):len()
                    elseif r >= (DestinationCenter - DepartureCenter):len() then
                        return (worldPos-DestinationCenter):len()
                    end
                    local L = DepartureCenter + (r * pipe)
                    local PipeWaypoint = "::pos{0,0," ..math.floor(L.x).. "," ..math.floor(L.y).. "," ..math.floor(L.z).. "}"
                    return PipeWaypoint
                end
                system.print("Pipe center: " ..DepartureCenterName.. " - " ..DestinationCenterName)
                system.setWaypoint(getPipeDistance())
                else
                local function getPipeDistance()
                    local DestinationCenter = vec3(stellarObjects[sortestPipeKeyId].center)
                    local DepartureCenter = vec3(stellarObjects[sortestPipeKey2Id].center)
                    local worldPos = shipPos
                    local pipe = (DestinationCenter - DepartureCenter):normalize()
                    local r = (worldPos -DepartureCenter):dot(pipe) / pipe:dot(pipe)
                    if r <= 0. then
                        return (worldPos-DepartureCenter):len()
                    elseif r >= (DestinationCenter - DepartureCenter):len() then
                        return (worldPos-DestinationCenter):len()
                    end
                    local L = DepartureCenter + (r * pipe)
                    local PipeWaypoint = "::pos{0,0," ..math.floor(L.x).. "," ..math.floor(L.y).. "," ..math.floor(L.z).. "}"
                    return PipeWaypoint
                end
                local clpipeMSG = "Pipe center: "..stellarObjects[sortestPipeKeyId].name[1].. " - " .. stellarObjects[sortestPipeKey2Id].name[1]
                system.print(clpipeMSG)
                system.setWaypoint(getPipeDistance())
                end
        onActionStart:
            args: [option4]
            lua: |
                local DepartureWaypoint = "::pos{0,0," ..math.floor(DepartureCenter.x)..","..math.floor(DepartureCenter.y)..","..math.floor(DepartureCenter.z).."}"
                if lalt==false then
                system.print(DepartureCenterName)
                system.setWaypoint(DepartureWaypoint)
                else
                system.print(stellarObjects[sortestPipeKey2Id].name[1])
                system.setWaypoint("::pos{0,0," ..math.floor(stellarObjects[sortestPipeKey2Id].center.x).. "," ..math.floor(stellarObjects[sortestPipeKey2Id].center.y).. "," ..math.floor(stellarObjects[sortestPipeKey2Id].center.z).. "}")
                end
                --if buttonSpace == true then
                --    local pos = system.getWaypointFromPlayerPos()
                --    system.print(pos)
                --end
        onActionStart:
            args: [option5]
            lua: |
                map = 1
                system.lockView(1)
                local gmap = mapGalaxy .. drawMap()
                system.setScreen(gmap)
                xDelta = xDelta + system.getMouseDeltaX()
                yDelta = yDelta + system.getMouseDeltaY()
        onActionStop:
            args: [option5]
            lua: |
                map = 0
                system.lockView(0)
        onActionStart:
            args: [option6]
            lua: |
                if varcombat > 300 and shield.getResistancesCooldown() == 0 and not GHUD_shield_auto_calibration then
                    local stress = shield.getStressRatioRaw()
                    local resistance = shield.getResistances()
                    local res = getRes(stress, resMAX)
                
                    if GHUD_shield_calibration_max then
                    if resistance[1] == res[1] and
                    resistance[2] == res[2] and
                    resistance[3] == res[3] and
                    resistance[4] == res[4]then
                        --system.print("Максимальный стресс не изменился")
                    else
                        if shield.setResistances(res[1],res[2],res[3],res[4]) == 1 then
                            system.print("Shield power has been set to max stress")
                            actionRes(res)
                            system.playSound('shieldNewResists.mp3')
                        else
                            system.print("ERR4")
                            system.playSound('shieldResistError.mp3')
                        end
                    end
                    else
                    local re1 = getResRatioBy2HighestDamage(stress)[1]
                    local re2 = getResRatioBy2HighestDamage(stress)[2]
                    local re3 = getResRatioBy2HighestDamage(stress)[3]
                    local re4 = getResRatioBy2HighestDamage(stress)[4]
                    if re1 == resistance[1] and
                    re2 == resistance[2] and
                    re3 == resistance[3] and
                    re4 == resistance[4] then
                        --system.print("2 максимальных стресса не изменились")
                    else
                        if shield.setResistances(re1,re2,re3,re4) == 1 then
                            system.print("Shield power has been split 50/50%")
                            actionRes(re)
                            system.playSound('shieldNewResists.mp3')
                        else
                            system.print("ERR5")
                            system.playSound('shieldResistError.mp3')
                        end
                    end
                    end
                end
        onActionStart:
            args: [option7]
            lua: |
                if buttonSpace==true then
                    if GHUD_shield_auto_calibration == true then
                    GHUD_shield_auto_calibration = false
                    system.print('Shield auto mode deactivated')
                    else
                    GHUD_shield_auto_calibration = true
                    system.print('Shield auto mode activated')
                    end
                end

                if buttonSpace==false then
                if GHUD_shield_calibration_max == true then
                    GHUD_shield_calibration_max = false
                    system.print('Shield max stress mode deactivated')
                    system.print('Shield 50/50 activated')
                else
                    GHUD_shield_calibration_max = true
                    system.print('Shield 50/50 deativated')
                    system.print('Shield max stress mode activated')
                end
                end
                end

                if GHUD_shield_auto_calibration
                then
                if GHUD_shield_calibration_max then
                    shieldText = "SHIELD (AUTO,MAX)"
                end
                if not GHUD_shield_calibration_max then
                    shieldText = "SHIELD (AUTO,50)"
                end
                else
                if GHUD_shield_calibration_max then
                    shieldText = "SHIELD (MANUAL,MAX)"
                end

                if not GHUD_shield_calibration_max then
                    shieldText = "SHIELD (MANUAL,50)"
                end
                end
        onActionStart:
            args: [option8]
            lua: |
                if lalt == false then
                    if shield.isActive() == 0 and shield.isVenting() == 0 then
                    shield.activate()
                    system.print("SHIELD ONLINE")
                    else
                    shield.deactivate()
                    system.print("SHIELD OFFLINE")
                    end
                end
        onActionStart:
            args: [option9]
            lua: |
                if shield.isVenting() == 1 then
                    shield.stopVenting()
                    system.print("Shield venting has been stopped!")
                    local shield_hp = shield.getShieldHitpoints()
                    last_shield_hp = shield_hp
                else
                    if venttime < venttimemax and venttime ~= 0 then
                    system.print("Shield venting is already stopped!")
                    else
                    shield.startVenting()
                    last_shield_hp = 0
                    system.print("Shield regeneration started!")
                    end
                end
        onActionStart:
            args: [lalt]
            lua: |
                altb=true
        onActionStop:
            args: [lalt]
            lua: |
                altb=false
        onActionStart:
            args: [lshift]
            lua: |
                lalt=true
        onActionStop:
            args: [lshift]
            lua: |
                lalt=false
        onInputText(text):
            lua: |
                if string.sub((text),1,3) == 'tag' then
                setTag(text)
                transponder.deactivate()
                unit.setTimer('tr',2)
                end

                if text =="drop" then
                local listships = core.getDockedConstructs()
                for i=1, #listships do
                    core.forceUndock(listships[i])
                end
                system.print("All ships were successfully undocked")
                end

                if string.find (text,'m::pos') then
                coratinka=1
                asteroidcoord = zeroConvertToWorldCoordinates(asteroidPOS)
                asteroidPOS = text:sub(2)
                databank_1.setStringValue(15,asteroidPOS)
                system.print("The marker was added to the map and saved to the databank")
                function ct()
                    while true do
                        local i=0
                        local ClosestPlanet={}
                        destination_bm=asteroidPOS
                        destination_wp=zeroConvertToWorldCoordinates(destination_bm,system)
                        ClosestPlanet.globalpipedistance=999999999999

                        ClosestPlanet.name, ClosestPlanet.distance = getClosestPlanet1(destination_wp)
                        for BodyId in pairs(atlas[0]) do
                            i=i+1
                            local startLocation=atlas[0][BodyId]
                            ClosestPlanet.pipename, ClosestPlanet.pipedistance=getClosestPipe1(destination_wp, startLocation)
                            if ClosestPlanet.pipedistance<ClosestPlanet.globalpipedistance then
                            ClosestPlanet.globalpipedistance=ClosestPlanet.pipedistance
                            ClosestPlanet.globalpipestart=startLocation.name[1]
                            ClosestPlanet.globalpipestop=ClosestPlanet.pipename
                            end
                            if i > 5 then
                            i = 0
                            coroutine.yield()
                            end
                        end
                        local SafeZoneDistance=getSafeZoneDistance(destination_wp)
                        if SafeZoneDistance < 0 then
                            ClosestDSafeZoneMessage="in safe-zone!"
                        else
                            ClosestDSafeZoneMessage=customDistance(SafeZoneDistance).. " to safe-zone"

                        end
                        posmessage="Closest pipe: "..ClosestPlanet.globalpipestart.." - "..ClosestPlanet.globalpipestop.." ("..customDistance(ClosestPlanet.globalpipedistance).."), closest planet: "..ClosestPlanet.name.." ("..customDistance(ClosestPlanet.distance).."), "..ClosestDSafeZoneMessage
                        system.print(posmessage)

                        coroutine.yield()
                        coratinka=0
                    end


                end
                ck = coroutine.create(ct)
                end
